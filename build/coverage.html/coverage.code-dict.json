{"/home/travis/build/npmtest/node-npmtest-socketstream/test.js":"/* istanbul instrument in package npmtest_socketstream */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-socketstream/lib.npmtest_socketstream.js":"/* istanbul instrument in package npmtest_socketstream */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_socketstream = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_socketstream = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-socketstream/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-socketstream && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_socketstream */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_socketstream\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_socketstream.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_socketstream.rollup.js'] =\n            local.assetsDict['/assets.npmtest_socketstream.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_socketstream.__dirname + '/lib.npmtest_socketstream.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/index.js":"// Initial entry point. Decides which directory of code to load\n\n// Load SocketStream core\nmodule.exports = require('./lib/socketstream.js');","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/socketstream.js":"// SocketStream 0.5\n// ----------------\n'use strict';\n\nrequire('colors');\n\nvar EventEmitter2 = require('eventemitter2').EventEmitter2,\n    debug = require('debug')('socketstream');\n\n/*\n * @ngdoc overview\n * @name socketstream\n * @description\n * Public Module for Socketstream\n */\n\n// Get current version from package.json\nvar version = exports.version = require('./utils/file').loadPackageJSON().version;\n\n// Set root path of your project\nvar root = exports.root = process.cwd().replace(/\\\\/g, '/'); // replace '\\' with '/' to support Windows\n\n// Warn if attempting to start without a cwd (e.g. through upstart script)\nif (root === '/') {\n  throw new Error('You must change into the project directory before starting your SocketStream app');\n}\n\n/**\n * @ngdoc overview\n * @name ss\n * @description\n * It reflects a similar API to the client API.\n *\n * Internal API object which is passed to sub-modules and can be used within your app.\n * Use with caution.\n *\n * To access it without it being passed `var ss = require('socketstream').api;`\n *\n * @type {{version: *, root: *, env: string, log: (*|exports), session: exports, add: Function}}\n */\nvar api = exports.api = {\n\n  /**\n   * @ngdoc property\n   * @name ss.version\n   * @returns {number} major.minor\n   */\n  version: version,\n  /**\n   * @ngdoc property\n   * @name ss.root\n   * @description\n   * By default the project root is the current working directory\n   * @returns {string} Project root\n   */\n  root: root,\n  /**\n   * @ngdoc property\n   * @name ss.env\n   * @returns {string} Execution environment type. To change set environment variable `NODE_ENV` or `SS_ENV`. 'development' by default.\n   */\n  env: (exports.env = (process.env['NODE_ENV'] || process.env['SS_ENV'] || 'development').toLowerCase()),\n\n  log: require('./utils/log'),\n\n  // loading http, client and ws\n  load: load,\n  unload: unload,\n\n  /**\n   * @ngdoc function\n   * @name ss.add\n   * @param {string} name - Key in the `ss` API.\n   * @param {function|number|boolean|string} fn - value or function\n   * @description\n   * Call from your app to safely extend the 'ss' internal API object passed through to your /server code\n   */\n  add: function(name, fn) {\n    if (api[name]) {\n      throw new Error('Unable to register internal API extension \\'' + name + '\\' as this name has already been taken');\n    } else {\n      api[name] = fn;\n      return true;\n    }\n  }\n};\n\n/**\n * Internal API for loading bundler plugins.\n */\napi.require = require('./utils/require')(api);\n\n/**\n * @ngdoc service\n * @name events\n * @description\n * Internal Event bus.\n *\n * Note: only used by the ss-console module for now. This idea will be expended upon in SocketStream 0.4\n *\n * 'server:start' is emitted when the server starts. If in production the assets will be saved before the event.\n */\nexports.events = api.events = new EventEmitter2();\n\n// Session & Session Store\nexports.session = api.session = require('./session')(api);\n\n// Publish Events\nvar publish = exports.publish = require('./publish')();\n\n// HTTP\nvar http = exports.http = api.http = require('./http')(api);\n\n// Client Asset Manager\nvar client = exports.client = require('./client')(api).init();\nexports.livereload = api.livereload = client.livereload;\n\n// Tasks for Orchestrator\nvar tasks = exports.tasks = require('./tasks')(api, client.options);\n\n// This is an experimental API, expect changes\nexports.task = api.task = tasks.add;\napi.defaultTask = tasks.defaultTask;\n\n/**\n * @ngdoc service\n * @name ss.client:client\n * @function\n *\n * @description\n * Allow other libs to send assets to the client\n */\n//\napi.client = {send: client.assets.send, dirs: client.dirs};\n\n/**\n * @ngdoc service\n * @name ss.server:server\n *\n * @description\n * Server parts used while running\n */\napi.server = {}; // used in tasks\n\n// Incoming Request Responders\nexports.responders = require('./request/index')(api);\n\n// Websocket Layer (transport, message responders, transmit incoming events)\nvar ws = exports.ws = require('./websocket/index')(api);\n\n// Only one instance of the server can be started at once\nvar serverInstance = null; //TODO enforce the one server instance in tasks\n\n// In the future the server will just be a middleware to use\n// Ensure server can only be started once\nexports.start = function() {\n  return serverInstance || (serverInstance = start.apply(null,arguments));\n};\n\nvar loaded = false;\n\n//TODO reload function that replaces API with virgin one.\n//TODO server/client API tracker in RPC\nfunction load() {\n  if (!loaded) {\n    var addons = [], skipped = [];\n\n    // load addon modules\n    api.require.forEach(['socketstream-*','socketstream.*'],function(mod,id) {\n      if (typeof mod === 'function') {\n        try {\n          mod(api);\n          addons.push(id);\n        } catch(ex) {\n          debug('Failed to load '+id+'. ',ex);\n        }\n      } else {\n        skipped.push(id);\n      }\n    });\n    debug('Addons: '+\n      addons.length? addons.join(' + ') + ' Loaded. ':' None. '+\n      skipped.length? skipped.join(' + ') + ' Skipped. ':'');\n\n    // load assets in cache\n    http.load();\n\n    // Load Client Asset Manager\n    client.load();\n\n    // Load internal and project responders\n    api.server.responders = exports.responders.load();\n\n    api.server.eventTransport = publish.transport.load();\n\n    // Extend the internal API with a publish object you can call from your own server-side code\n    api.publish = publish.api(api.server.eventTransport);\n\n    // Bind responders to websocket\n    ws.load(api.server.responders, api.server.eventTransport);\n\n    debug('API loaded.');\n  }\n  loaded = true;\n}\n\nfunction unload() {\n  loaded = false;\n\n  tasks.unload();\n  client.unload();\n  client.assets.unload();\n  http.unload();\n  api.server.responders = undefined;\n  ws.unload();\n}\n\nvar exitRegistered;\n\n/**\n * @ngdoc function\n * @name start\n * @param {HTTPServer} server Instance of the server from the http module\n * @description\n * Starts the development or production server\n */\nfunction start() {\n\n  var plan = tasks.plan(arguments);\n\n  // Hook in streaming if called with HTTP server\n  if (plan.httpServer) {\n    // depr\n    api.log.error('The API has changed you can no longer create the HTTP server yourself.');\n  }\n\n  load();\n  tasks.defaults();\n\n  tasks.start(plan.targets,plan.callback);\n\n  if (!exitRegistered) {\n    process.on('exit', api.unload);\n    exitRegistered = true;\n  }\n\n  return api;\n}\n\n/**\n * @ngdoc function\n * @name set\n * @param {String} where Path in settings or '*'\n * @param {String|Object} what Value for setting or object when using star.\n * @description\n * Overrides settings for root/client/server.\n */\nexports.set = function(where,what) {\n  var path = require('path');\n\n  if (where === '*') {\n    if (what.root) {\n      if (path.isAbsolute(what.root)) {\n        exports.root = api.root = what.root;\n      } else {\n        var scriptBase = path.dirname(process.argv[1]);\n        exports.root = api.root = path.join(scriptBase,what.root);\n      }\n    }\n\n    if (what.client) {\n      client.set(what.client);\n    }\n    if (what.http) {\n      http.set(what.http);\n    }\n    //TODO vars, locals remembered as fallbacks\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/utils/file.js":"'use strict';\n\n/**\n * @ngdoc service\n * @name utils\n * @function\n *\n * @description\n * Contains utils modules for working with file system and some additional helpers\n */\n\n/**\n * @ngdoc service\n * @name utils.file:file\n * @function\n *\n * @description\n * This is used to maintain lists of userIds to socketIds and channelIds to socketIds\n */\n\nvar fs = require('fs'),\n    path = require('path');\n\n/**\n * Identifies if the path is hidden\n *\n * @param  {String}  path\n * @return {Boolean}\n */\nfunction isHidden(path) {\n    return path.match(/(^_|^\\.|~$)/);\n}\n\n/**\n * Identifies if the path is directory\n *\n * @param  {String}  abspath   Absolute path, should be already have replaced '\\' with '/' to support Windows\n * @param  {Object}  found     Object: {dirs: [], files: [] }, contains information about directory's files and subdirectories\n * @return {Object}            Updated 'found' object\n */\nfunction isDir(abspath, found) {\n    var stat       = fs.statSync(abspath),\n        abspathAry = abspath.split('/'),\n        data,\n        file_name;\n\n    if (!found) {\n        found = {dirs: [], files: [] }\n    }\n\n    if (stat.isDirectory() && !isHidden(abspathAry[abspathAry.length - 1])) {\n        found.dirs.push(abspath);\n\n        /* If we found a directory, recurse! */\n        data        = exports.readDirSync(abspath);\n        found.dirs  = found.dirs.concat(data.dirs);\n        found.files = found.files.concat(data.files);\n\n    } else {\n\n        abspathAry = abspath.split('/');\n        file_name  = abspathAry[abspathAry.length - 1];\n\n        if (!isHidden(file_name)) {\n            found.files.push(abspath);\n        }\n    }\n    return found;\n}\n\n/**\n * @ngdoc service\n * @name utils.file#readDirSync\n * @methodOf utils.file:file\n * @function\n *\n * @description\n * Reads the contents of a dir. Adapted from https://gist.github.com/825583\n *\n * @param {String} start Directory absolute path to lookup\n */\nexports.readDirSync = function(start) {\n    var stat,\n        found = {dirs: [], files: [] },\n        files,\n        abspath,\n        x, l;\n\n    try {\n        /* Use lstat to resolve symlink if we are passed a symlink */\n        stat = fs.lstatSync(start)\n\n        /* Read through all the files in this directory */\n        if (stat.isDirectory()) {\n            files = fs.readdirSync(start).sort();\n\n            for (x = 0, l = files.length; x < l; x++) {\n                /* replace '\\' with '/' to support Windows */\n                abspath = path.join(start, files[x]).replace(/\\\\/g, '/');\n\n                found = isDir(abspath, found);\n            }\n        } else {\n            throw (new Error('path: ' + start + ' is not a directory'));\n        }\n        return found;\n\n    } catch (e) {\n        /* Ignore if optional dirs are missing */\n        if (e.code !== 'ENOENT') {\n            throw (e);\n        }\n        return false;\n    }\n};\n\n/**\n * @ngdoc service\n * @name utils.file#loadPackageJSON\n * @methodOf utils.file:file\n * @function\n *\n * @description\n * Loads SocketStream's package.json file from the root directory\n *\n * @return {Object|Error} JSON object or thorws an eror if unable to find or parse SocketStream's package.json file\n */\nexports.loadPackageJSON = function() {\n    try {\n        return JSON.parse(fs.readFileSync(__dirname + '/../../package.json'));\n    } catch (e) {\n        throw ('Error: Unable to find or parse SocketStream\\'s package.json file');\n    }\n};\n\n/**\n * @ngdoc service\n * @name utils.file#isDir\n * @methodOf utils.file:file\n * @function\n *\n * @description\n * In synchronous mode returns if givven `filePath` is directory or not\n *\n * @return {Boolean} TRUE if givven `filePath` is dorectory\n */\nexports.isDir = function(filePath) {\n    return fs.statSync(filePath).isDirectory();\n};\n\n/**\n * @ngdoc service\n * @name utils.file#findExtForBasePath\n * @methodOf utils.file:file\n * @function\n *\n * @description\n * Given a basename, find a matching file with an extension.\n *\n * @example:\n * <pre>\n *   findExtForBase('views/main')       => '.jade'\n *   findExtForBase('css/i-dont-exist') => null\n * </pre>\n *\n * @param {Object} basepath Path to directory\n * @returns {Array|null} Array of files or `null`\n */\nexports.findExtForBasePath = function(basepath) {\n    var files = fs.readdirSync(path.join(basepath, '..')),\n        basename = path.basename(basepath),\n        basenameRegex = new RegExp('^' + basename);\n\n    files = files.filter(function(file) {\n        return file.match(basenameRegex) && path.extname(file);\n    });\n    return files.length ? path.extname(files.sort()[0]) : null;\n};","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/utils/log.js":"'use strict';\n/**\n * @ngdoc service\n * @name ss.log:log\n * @function\n *\n * @description\n * Contains method stubs for logging to console (by default) or\n * whatever logging provider you choose.\n */\n\n\n\n\n/**\n * @ngdoc function\n * @name ss.log#trace\n * @methodOf ss.log:log\n * @function\n * @description\n * Trace function calls in socketstream and plugins. By default nothing is done.\n * If you want to switch on tracing override the `trace` method.\n * ```\n * var ss = require('socketstream');\n * ss.api.log.trace = function() {\n * console.log.apply(console,arguments);\n * };\n * ```\n */\nexports.trace = function() {\n};\n\n/**\n * @ngdoc function\n * @name ss.log#debug\n * @methodOf ss.log:log\n * @function\n *\n * @description\n * Debug level logging, uses console.log by default. Override by assigning a\n * function that takes the same parameters as console.log:\n * ```\n * var ss = require('socketstream');\n * ss.api.log.debug = console.log;\n * ```\n *\n * @example\n * ```\n * ss.log.debug(\"Something fairly trivial happened\");\n * ```\n */\nexports.debug = console.log;\n\n/**\n * @ngdoc service\n * @name ss.log#info\n * @methodOf ss.log:log\n * @function\n *\n * @description\n * Info level logging, uses console.log by default. Override by assigning a\n * function that takes the same parameters as console.log.\n *\n * @example\n * ```\n * ss.log.info(\"Just keeping you informed\");\n * ```\n */\nexports.info = console.log;\n\n/**\n * @ngdoc function\n * @name ss.log#warn\n * @methodOf ss.log:log\n * @function\n *\n * @description\n * Warn level logging, uses console.log by default. Override by assigning a\n * function that takes the same parameters as console.log:\n * ```\n * var ss = require('socketstream'),\n *     winston = require('winston');\n * ss.log.warn = winston.warn;\n * ```\n *\n * @example\n * ```\n * ss.log.warn(\"Something unexpected happened!\");\n * ```\n */\nexports.warn = console.log;\n\n\n/**\n * @ngdoc function\n * @name ss.log#error\n * @methodOf ss.log:log\n * @function\n *\n * @description\n * Error level logging, uses console.error by default. Override by assigning a\n * function that takes the same parameters as console.error.\n *\n * @example\n * ```\n * ss.log.error(\"Time to wakeup the sysadmin\");\n * ```\n */\nexports.error = console.error;\n\nvar nextClientIssue = (new Date()).getTime();\n\nexports.clientIssue = function clientIssue(client,options,err,more) {\n  var info = [''];\n  if (options.serveDebugInfo) {\n    err.userInfo = info;\n  }\n  info.push(err.message);\n  info.push('client='+client.id);\n  if (err.stack) {\n    info = info.concat(err.stack.split('\\n').splice(1));\n  }\n  if (more) {\n    info.push('more:');\n    info.push(JSON.stringify(more));\n  }\n\n  var number = nextClientIssue++;\n\n  Object.defineProperty(err, 'userInfoHTML', {\n    get: function() {\n      return this.userInfo? this.userInfo.join('<br>') : ' issue='+number;\n    }\n  });\n  Object.defineProperty(err, 'userInfoText', {\n    get: function() {\n      return this.userInfo? this.userInfo.join('\\n') : ' issue='+number;\n    }\n  });\n\n  this.error(('Couldn\\'t serve client '+client.name+',').red, 'issue='+number, info.join('\\n'));\n\n  return number;\n};\n\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/utils/require.js":"'use strict';\n\nvar path = require('path'),\n\tfs = require('fs'),\n\tfindup = require('findup-sync'),\n\tresolve = require('resolve'),\n\tmicromatch = require('micromatch'),\n\tdebug = require('debug')('require'),\n\tcontexts = {};\n\nmodule.exports = function(ss) {\n\t/*\n\t * Require a module by id that is located.\n\t * - builtin module in context\n\t * - module relative to app.js\n\t * - module in socketstream, in project or above\n\t * - the default module\n\t *\n\t * Currently only support .js files\n\t *\n\t * Currently doesn't cache anything. It could cache builtin names.\n\t * Or it could remember the result of a call.\n\n\t * @param {function} callback The third parameter can be a callback function called when the\n\t module isn't found. If it returns something that will be the resolved module.\n\t */\n\tfunction requires(id, contextPath, defaultId) {\n\t\tvar context, callback;\n\t\tif (typeof defaultId === 'function') {\n\t\t\tcallback = defaultId;\n\t\t\tdefaultId = null;\n\t\t}\n\t\tif (contextPath) {\n\t\t\tcontext = contexts[contextPath];\n\t\t\tif (context === undefined) {\n\t\t\t\tcontext = contexts[contextPath] = {\n\t\t\t\t\trel : context,\n\t\t\t\t\tprefix: path.join(__dirname, '..', contextPath),\n\t\t\t\t\tinContext: function(id) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tvar p = path.join(context.prefix,id);\n\t\t\t\t\t\t\tif (require.resolve(p)) { // gives full path\n\t\t\t\t\t\t\t\treturn require(p);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch(ex) {}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n    }\n\n    switch(typeof id) {\n      case 'object':\n      case 'function':\n        if (id) {\n          return id; // straight object/function will just resolve straight away\n        }\n        break;\n      case 'string':\n        if (context) {\n          // builtin modules take first priority\n          var inContext = context.inContext(id);\n          if (inContext) { return inContext; }\n\n        }\n\n        // if relative base on main script location\n        if (id.charAt(0) === '.') {\n          var inProject = path.join(ss.root,id);\n          if (fs.existsSync(inProject+'.js')) {\n            debug('found '+id);\n            return require(inProject);\n          }\n        }\n\n        // getting a packaged module\n        var mod = projectOrHereRequire(id,ss.root);\n        if (mod) {\n          debug('found '+id+' in project or SocketStream');\n          return require(mod);\n        }\n        break;\n    }\n\n\t\tif (context && defaultId) {\n\t\t\t// default looked up in context first\n\t\t\tvar defaultInContext = context.inContext(defaultId);\n\t\t\tif (defaultInContext) { return defaultInContext; }\n\n\t\t\t// all bets are off\n\t\t\tmod = projectOrHereRequire(defaultId,ss.root);\n\t\t\tif (mod) {\n\t\t\t\tdebug('found '+defaultId+' in project or SocketStream');\n\t\t\t\treturn require(mod);\n\t\t\t}\n\t\t}\n\n\t\tif (callback) {\n\t\t\treturn callback({\n\t\t\t\tid:id\n\t\t\t});\n\t\t}\n\t\tthrow new Error('Cannot find module \"' + id + '\" in socketstream or project');\n\t}\n\n\tfunction resolves(id) {\n\t\treturn projectOrHereRequire(id,ss.root);\n\t}\n\n\trequires.resolve = resolves;\n\n\tfunction forEach(pattern,fn) {\n\t\tvar packageJSON = findup('package.json', {cwd:ss.root});\n\t\tif (packageJSON) {\n\t\t\tvar dependencies = require(packageJSON).dependencies;\n\t\t\tdependencies = dependencies? Object.keys(dependencies) : [];\n\t\t\tvar matches = micromatch(dependencies,pattern);\n\t\t\tvar mod = {};\n\t\t\tmatches.forEach(function(id) {\n\t\t\t\tif (mod[id] === undefined) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tmod[id] = resolve.sync(id, { package: packageJSON, basedir: ss.root});\n\t\t\t\t\t\tdebug('matched '+id+' from pattern '+pattern);\n\t\t\t\t\t\tfn(require(mod[id]),id);\n\t\t\t\t\t} catch(ex) {\n\t\t\t\t\t\t//TODO debug log failed to use SocketStream Add-On\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\trequires.forEach = forEach;\n\n\treturn requires;\n};\n\n// return path to found, project first\nfunction projectOrHereRequire(id,root) {\n\ttry {\n\t\treturn resolve.sync(id, {\n\t\t\tpackage: path.join(root,'package.json'),\n\t\t\tpaths: [root],\n\t\t\tbasedir:root\n\t\t});\n\t} catch(ex) {\n\t\t// console.error(ex);\n\t}\n\n\tvar here = path.join(__dirname,'..','..');\n\ttry {\n\t\tvar p = resolve.sync(id, {\n\t\t\tpackage: path.join(here,'package.json'),\n\t\t\tpaths: [here],\n\t\t\tbasedir:here\n\t\t});\n\t\treturn p;\n\t} catch(ex) {\n\t\t// console.error(ex);\n\t}\n}\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/session/index.js":"// Sessions\n// --------\n// Creates a wrapper around a Connect Session Store object\n'use strict';\n\nvar channels = require('./channels'),\n    subscriptions = require('../websocket/subscriptions'),\n    uuid = require('uuid'),\n    debug = require('debug')('socketstream:session'),\n    sessionStore,\n    strategy = {};\n\nvar Store = require('./store'),\n    MemoryStore = require('./memory'),\n    Cookie = require('./cookie'),\n    Session = require('./session');\n\n/**\n * Warning message for `MemoryStore` usage in production.\n * @private\n */\nvar warning = ['Warning: connect.session() MemoryStore is not',\n    'designed for a production environment, as it will leak',\n    'memory, and will not scale past a single process.'].join('\\n');\n\nmodule.exports = function(ss) {\n\n  var api = {\n\n    // Expose options which can be changed in your app\n    options: {\n      maxAge: null, // by default session exists for duration of user agent (e.g. until browser is closed)\n      secret: \"SocketStream\" //TODO add config todo for dev time logging\n    },\n    //TODO config point for ss.session.options.cookie\n\n    strategy: strategy,\n\n    setStrategy: function(_strategy) {\n      this.strategy = strategy = _strategy;\n      debug('session strategy defined.');\n    },\n\n    Store: Store,\n    MemoryStore: MemoryStore,\n    Cookie: Cookie,\n    Session: Session,\n\n    // Manually create a new session (for running server-side tests, or calling responders from ss-console)\n    create: function() {\n      var sessionId = uuid.v1();\n      this.strategy.create(sessionId);\n      debug('created session %s',sessionId);\n      return sessionId;\n    },\n\n    // Find a session from the Connect Session Store\n    // Note: Sessions are automatically created by the connect.session()\n    // middleware when the browser makes a HTTP request\n    find: function(sessionId, socketId, cb) {\n      return api.store.get().load(sessionId, function(err, session) {\n        // Create a new session if we don't have this sessionId in memory\n        // Note: in production you should be using Redis or another\n        // persistent store so this should rarely happen\n        if (!session) {\n          session = strategy.create(sessionId);\n          debug('created session for %s',sessionId);\n        } else {\n          debug('using existing session for %s',sessionId);\n        }\n\n        // Append methods to session object\n        session.channel = channels(ss, session, socketId);\n        session.setUserId = function(userId, cb) {\n          if (!cb) {\n            cb = function() {};\n          }\n          if (userId) {\n            this.userId = userId;\n            this._bindToSocket();\n          } else if (this.userId) {  // if null (i.e. user has signed out)\n            subscriptions.user.remove(this.userId, socketId);\n            delete this.userId;\n          }\n          return this.save(cb);\n        };\n\n        // Bind username and any channel subscriptions to this socketID on each request\n        session._bindToSocket = function() {\n          if (session.userId) {\n            subscriptions.user.add(session.userId, socketId);\n          }\n          if ((session.channels) && session.channels.length > 0) {\n            session.channel._bindToSocket();\n          }\n          return this;\n        };\n        session.save = function(cb) {\n          return sessionStore.set(sessionId, session, cb);\n        };\n        session._bindToSocket();\n        return cb(session);\n      });\n    },\n\n    extractSocketSessionToken: function(request) {\n      if (!this.strategy.extractSocketSessionToken) {\n        throw new Error('No session strategy defined! Did you forget to \"npm install socketstream-cookie-session\" ?');\n      }\n      var id = this.strategy.extractSocketSessionToken(request, this.options);\n      debug('extracted session id %s',id);\n      return id;\n    },\n\n    // Allow use of any Connect Session Store\n    store: {\n      use: function(nameOrStore, options) {\n        var RedisStore;\n        debug('Using %s Store for ss.session.store',nameOrStore==='redis'?'Redis':'Custom');\n        // Allow any Connect Session Store *instance* to be used\n        //jshint -W093\n        return (sessionStore = nameOrStore === 'redis' ?\n          (RedisStore = ss.require('connect-redis')(api), new RedisStore(options)) :\n          nameOrStore);\n      },\n      get: function() {\n        if (sessionStore == null) {\n          // notify user that this store is not\n          // meant for a production environment\n          if ('production' === ss.env) {\n            ss.log.warn(warning);\n          }\n          // Define default session store (no default impl for now, is set in session strategy addon socketstream-cookie-session)\n          sessionStore = new api.MemoryStore();\n          debug('Using MemoryStore for ss.session.store');\n        }\n        return sessionStore;\n      }\n    }\n  };\n\n  return api;\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/session/channels.js":"// Session Channels\n// ----------------\n// Provides an interface allowing you to subscribe or unsubscribe the session to a private channel\n'use strict';\n\nrequire('colors');\n\n// Stores the relationship between sessionId and socketIds\nvar subscriptions = require('../websocket/subscriptions');\n\nmodule.exports = function(ss, session, socketId) {\n  return {\n\n    // Lists all the channels the client is currently subscribed to    \n    list: function() {\n      return session.channels || [];\n    },\n\n    // Subscribes the client to one or more channels    \n    subscribe: function(names, cb) {\n      if (!cb) {\n        cb = function() {};\n      }\n      if (!session.channels) {\n        session.channels = [];\n      }\n      forceArray(names).forEach(function(name) {\n        if (session.channels.indexOf(name) === -1) { // clients can only join a channel once\n          session.channels.push(name);\n          return ss.log.info('i'.green + ' subscribed sessionId '.grey + session.id + ' to channel '.grey + name);\n        }\n      });\n      this._bindToSocket();\n      return session.save(cb);\n    },\n\n    // Unsubscribes the client from one or more channels\n    unsubscribe: function(names, cb) {\n      if (!cb) {\n        cb = function() {};\n      }\n      if (!session.channels) {\n        session.channels = [];\n      }\n      forceArray(names).forEach(function(name) {\n        var i;\n        if ((i = session.channels.indexOf(name)) >= 0) {\n          session.channels.splice(i, 1);\n          subscriptions.channel.remove(name, socketId);\n          return ss.log.info('i'.green + ' unsubscribed sessionId '.grey + session.id + ' from channel '.grey + name);\n        }\n      });\n      return session.save(cb);\n    },\n\n    // Unsubscribes the client from all channels    \n    reset: function(cb) {\n      if (!cb) {\n        cb = function() {};\n      }\n      return this.unsubscribe(this.list(), cb);\n    },\n    _bindToSocket: function() {\n      if (!session.channels) {\n        session.channels = [];\n      }\n      return forceArray(session.channels).forEach(function(name) {\n        return subscriptions.channel.add(name, socketId);\n      });\n    }\n  };\n};\n\n// Private\n\nfunction forceArray(input) {\n  return typeof input === 'object' && input.slice() || [input];\n}\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/websocket/subscriptions.js":"// Websocket ID subscriptions\n// --------------------------\n// Stores a list of which socket IDs are subscribed to which users or channels\n// and delivers events accordingly\n'use strict';\n\nvar UniqueSet = require('../utils/unique_set').UniqueSet;\n\nmodule.exports = {\n  user: new UniqueSet,\n  channel: new UniqueSet\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/utils/unique_set.js":"'use strict';\n\n/**\n * @ngdoc service\n * @name utils.unique_set:UniqueSet\n * @function\n *\n * @description\n * This is used to maintain lists of userIds to socketIds and channelIds to socketIds\n */\nexports.UniqueSet = (function() {\n\n  function UniqueSet() {\n    this.data = {};\n  }\n\n  /**\n   * @ngdoc service\n   * @name utils.UniqueSet#add\n   * @methodOf utils.unique_set:UniqueSet\n   * @function\n   *\n   * @description\n   * Add specific `key/value` set\n   *\n   * @param {String} key   Key name\n   * @param {Mixed}  value Value to be assigned to the `key`\n   */\n  UniqueSet.prototype.add = function(key, value) {\n    var set;\n    if (!((key) && (value))) {\n      return false;\n    }\n    set = this.data[key];\n    if (set) {\n      if (set.indexOf(value) === -1) {\n        return set.push(value);\n      }\n    } else {\n      this.data[key] = [value];\n      return this.data[key];\n    }\n  };\n\n  /**\n   * @ngdoc service\n   * @name utils.UniqueSet#remove\n   * @methodOf utils.unique_set:UniqueSet\n   * @function\n   *\n   * @description\n   * Remove specific `key/value` set\n   *\n   * @param {String}    key   Key name\n   * @param {Mixed}     value Value related to the `key`\n   * @return {Boolean}        Remove state\n   */\n  UniqueSet.prototype.remove = function(key, value) {\n    var i;\n    if (this.data[key] === void 0) {\n      return;\n    }\n    if ((i = this.data[key].indexOf(value)) >= 0) {\n      this.data[key].splice(i, 1);\n      if (this.data[key].length === 0) {\n        return delete this.data[key];\n      }\n    }\n  };\n\n  /**\n   * @ngdoc service\n   * @name utils.UniqueSet#removeFromAll\n   * @methodOf utils.unique_set:UniqueSet\n   * @function\n   *\n   * @description\n   * Remove all specific `key/value` sets accotding to `value`\n   *\n   * @param {Mixed}     value Value as a link for removal all the sets\n   * @return {Boolean}        Removal status\n   */\n  UniqueSet.prototype.removeFromAll = function(value) {\n    var _this = this;\n    return this.keys().forEach(function(key) {\n      return _this.remove(key, value);\n    });\n  };\n\n  /**\n   * @ngdoc service\n   * @name utils.UniqueSet#keys\n   * @methodOf utils.unique_set:UniqueSet\n   * @function\n   *\n   * @description\n   * Returns array of keys\n   *\n   * @return {Array} Array of all the keys names\n   */\n  UniqueSet.prototype.keys = function() {\n    return Object.keys(this.data);\n  };\n\n  /**\n   * @ngdoc service\n   * @name utils.UniqueSet#members\n   * @methodOf utils.unique_set:UniqueSet\n   * @function\n   *\n   * @description\n   * Returns array with all the values by certain `key`\n   *\n   * @return {Array}  Array of all the keys for specified `key`\n   */\n  UniqueSet.prototype.members = function(key) {\n    return this.data[key] || [];\n  };\n\n  return UniqueSet;\n\n})();\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/session/store.js":"/*!\n * Connect - session - Store\n * Copyright(c) 2010 Sencha Inc.\n * Copyright(c) 2011 TJ Holowaychuk\n * MIT Licensed\n */\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar EventEmitter = require('eventemitter2').EventEmitter2,\n  debug = require('debug')('sessionstore'),\n  Session = require('./session'),\n  Cookie = require('./cookie');\n\n/**\n * Initialize abstract `Store`.\n *\n * @param options {Object} Store options\n * @api private\n */\n\nvar Store = module.exports = function Store(){};\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\n\nStore.prototype = Object.create(EventEmitter.prototype);\n\n/**\n * Re-generate the given requests's session.\n *\n * @param {IncomingRequest} req\n * @return {Function} fn\n * @api public\n */\n\nStore.prototype.regenerate = function(req, fn){\n  var self = this;\n  this.destroy(req.sessionID, function(err){\n    self.generate(req);\n    fn(err);\n  });\n};\n\n/**\n * Load a `Session` instance via the given `sid`\n * and invoke the callback `fn(err, sess)`.\n *\n * @param {String} sid\n * @param {Function} fn\n * @api public\n */\n\nStore.prototype.load = function(sid, fn){\n  var self = this;\n  this.get(sid, function(err, sess){\n    if (err) { debug('failed to get %s',sid); return fn(err); }\n    if (!sess) { debug('no session for %s',sid); return fn(); }\n    var req = { sessionID: sid, sessionStore: self };\n    sess = self.createSession(req, sess); // recreate prototypes on persisted data\n    fn(null, sess);\n  });\n};\n\n/**\n * Create session from JSON `sess` data.\n *\n * @param {IncomingRequest} req\n * @param {Object} sess\n * @return {Session}\n * @api private\n */\n\nStore.prototype.createSession = function(req, sess){\n  var expires = sess.cookie.expires\n    , orig = sess.cookie.originalMaxAge;\n  sess.cookie = new Cookie(sess.cookie);\n  if ('string' === typeof expires) { sess.cookie.expires = new Date(expires); }\n  sess.cookie.originalMaxAge = orig;\n  req.session = new Session(req, sess);\n  return req.session;\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/session/session.js":"/*!\n * Connect - session - Session\n * Copyright(c) 2010 Sencha Inc.\n * Copyright(c) 2011 TJ Holowaychuk\n * MIT Licensed\n */\n'use strict';\n\n/**\n * Expose Session.\n */\n\nmodule.exports = Session;\n\n/**\n * Create a new `Session` with the given request and `data`.\n *\n * @param {IncomingRequest} req\n * @param {Object} data\n * @api private\n */\n\nfunction Session(req, data) {\n  Object.defineProperty(this, 'req', { value: req });\n  Object.defineProperty(this, 'id', { value: req.sessionID });\n\n  if (typeof data === 'object' && data !== null) {\n    // merge data into this, ignoring prototype properties\n    for (var prop in data) {\n      if (!(prop in this)) {\n        this[prop] = data[prop]\n      }\n    }\n  }\n}\n\n/**\n * Update reset `.cookie.maxAge` to prevent\n * the cookie from expiring when the\n * session is still active.\n *\n * @return {Session} for chaining\n * @api public\n */\n\nSession.prototype.touch = function(){\n  return this.resetMaxAge();\n};\n\n/**\n * Reset `.maxAge` to `.originalMaxAge`.\n *\n * @return {Session} for chaining\n * @api public\n */\n\nSession.prototype.resetMaxAge = function(){\n  this.cookie.maxAge = this.cookie.originalMaxAge;\n  return this;\n};\n\n/**\n * Save the session data with optional callback `fn(err)`.\n *\n * @param {Function} fn\n * @return {Session} for chaining\n * @api public\n */\n\nSession.prototype.save = function(fn){\n  this.req.sessionStore.set(this.id, this, fn || function(){});\n  return this;\n};\n\n/**\n * Re-loads the session data _without_ altering\n * the maxAge properties. Invokes the callback `fn(err)`,\n * after which time if no exception has occurred the\n * `req.session` property will be a new `Session` object,\n * although representing the same session.\n *\n * @param {Function} fn\n * @return {Session} for chaining\n * @api public\n */\n\nSession.prototype.reload = function(fn){\n  var req = this.req\n    , store = this.req.sessionStore;\n  store.get(this.id, function(err, sess){\n    if (err) {return fn(err);}\n    if (!sess) {return fn(new Error('failed to load session'));}\n    store.createSession(req, sess);\n    fn();\n  });\n  return this;\n};\n\n/**\n * Destroy `this` session.\n *\n * @param {Function} fn\n * @return {Session} for chaining\n * @api public\n */\n\nSession.prototype.destroy = function(fn){\n  delete this.req.session;\n  this.req.sessionStore.destroy(this.id, fn);\n  return this;\n};\n\n/**\n * Regenerate this request's session.\n *\n * @param {Function} fn\n * @return {Session} for chaining\n * @api public\n */\n\nSession.prototype.regenerate = function(fn){\n  this.req.sessionStore.regenerate(this.req, fn);\n  return this;\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/session/cookie.js":"/*!\n * Connect - session - Cookie\n * Copyright(c) 2010 Sencha Inc.\n * Copyright(c) 2011 TJ Holowaychuk\n * MIT Licensed\n */\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar merge = require('utils-merge')\n  , cookie = require('cookie');\n\n/**\n * Initialize a new `Cookie` with the given `options`.\n *\n * @param {IncomingMessage} req\n * @param {Object} options\n * @api private\n */\n\nvar Cookie = module.exports = function Cookie(options) {\n  this.path = '/';\n  this.maxAge = null;\n  this.httpOnly = true;\n  if (options) {merge(this, options);}\n  this.originalMaxAge = undefined === this.originalMaxAge ?\n      this.maxAge :\n      this.originalMaxAge;\n};\n\n/*!\n * Prototype.\n */\n\nCookie.prototype = {\n\n  /**\n   * Set expires `date`.\n   *\n   * @param {Date} date\n   * @api public\n   */\n\n  set expires(date) {\n    this._expires = date;\n    this.originalMaxAge = this.maxAge;\n  },\n\n  /**\n   * Get expires `date`.\n   *\n   * @return {Date}\n   * @api public\n   */\n\n  get expires() {\n    return this._expires;\n  },\n\n  /**\n   * Set expires via max-age in `ms`.\n   *\n   * @param {Number} ms\n   * @api public\n   */\n\n  set maxAge(ms) {\n    this.expires = 'number' === typeof ms ?\n        new Date(Date.now() + ms) :\n        ms;\n  },\n\n  /**\n   * Get expires max-age in `ms`.\n   *\n   * @return {Number}\n   * @api public\n   */\n\n  get maxAge() {\n    return this.expires instanceof Date ?\n        this.expires.valueOf() - Date.now() :\n        this.expires;\n  },\n\n  /**\n   * Return cookie data object.\n   *\n   * @return {Object}\n   * @api private\n   */\n\n  get data() {\n    return {\n        originalMaxAge: this.originalMaxAge\n      , expires: this._expires\n      , secure: this.secure\n      , httpOnly: this.httpOnly\n      , domain: this.domain\n      , path: this.path\n    }\n  },\n\n  /**\n   * Return a serialized cookie string.\n   *\n   * @return {String}\n   * @api public\n   */\n\n  serialize: function(name, val){\n    return cookie.serialize(name, val, this.data);\n  },\n\n  /**\n   * Return JSON representation of this cookie.\n   *\n   * @return {Object}\n   * @api private\n   */\n\n  toJSON: function(){\n    return this.data;\n  }\n};","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/session/memory.js":"/*!\n * express-session\n * Copyright(c) 2010 Sencha Inc.\n * Copyright(c) 2011 TJ Holowaychuk\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar Store = require('./store'),\n    debug = require('debug')('socketstream:session');\n\n/**\n * Shim setImmediate for node.js < 0.10\n * @private\n */\n\n/* istanbul ignore next */\nvar defer = typeof setImmediate === 'function' ?\n    setImmediate :\n    function(fn){ process.nextTick(fn.bind.apply(fn, arguments)) }\n\n/**\n * Module exports.\n */\n\nmodule.exports = MemoryStore\n\n/**\n * A session store in memory.\n * @public\n */\n\nfunction MemoryStore() {\n  Store.call(this)\n  this.sessions = Object.create(null)\n}\n\n/**\n * Inherit from Store.\n */\nMemoryStore.prototype = Object.create(Store.prototype);\n\n/**\n * Get all active sessions.\n *\n * @param {function} callback\n * @public\n */\n\nMemoryStore.prototype.all = function all(callback) {\n  var sessionIds = Object.keys(this.sessions)\n  var sessions = Object.create(null)\n\n  for (var i = 0; i < sessionIds.length; i++) {\n    var sessionId = sessionIds[i]\n    var session = getSession(this.sessions, sessionId)\n\n    if (session) {\n      sessions[sessionId] = session;\n    }\n  }\n\n  if (callback) {\n     defer(callback, null, sessions);\n  }\n}\n\n/**\n * Clear all sessions.\n *\n * @param {function} callback\n * @public\n */\n\nMemoryStore.prototype.clear = function clear(callback) {\n  this.sessions = Object.create(null)\n  if (callback) {\n     defer(callback);\n  }\n}\n\n/**\n * Destroy the session associated with the given session ID.\n *\n * @param {string} sessionId\n * @public\n */\n\nMemoryStore.prototype.destroy = function destroy(sessionId, callback) {\n  delete this.sessions[sessionId]\n  if (callback) {\n     defer(callback);\n  }\n}\n\n/**\n * Fetch session by the given session ID.\n *\n * @param {string} sessionId\n * @param {function} callback\n * @public\n */\n\nMemoryStore.prototype.get = function get(sessionId, callback) {\n  defer(callback, null, getSession(this.sessions, sessionId))\n}\n\n/**\n * Commit the given session associated with the given sessionId to the store.\n *\n * @param {string} sessionId\n * @param {object} session\n * @param {function} callback\n * @public\n */\n\n/**\n * Get number of active sessions.\n *\n * @param {function} callback\n * @public\n */\n\nMemoryStore.prototype.length = function length(callback) {\n  this.all(function (err, sessions) {\n    if (err) { return callback(err); }\n    callback(null, Object.keys(sessions).length)\n  })\n}\n\nMemoryStore.prototype.set = function set(sessionId, session, callback) {\n  this.sessions[sessionId] = JSON.stringify(session)\n  if (callback) {\n     defer(callback);\n  }\n}\n\n/**\n * Touch the given session object associated with the given session ID.\n *\n * @param {string} sessionId\n * @param {object} session\n * @param {function} callback\n * @public\n */\n\nMemoryStore.prototype.touch = function touch(sessionId, session, callback) {\n  var currentSession = getSession(this.sessions, sessionId)\n\n  if (currentSession) {\n    // update expiration\n    currentSession.cookie = session.cookie\n    this.sessions[sessionId] = JSON.stringify(currentSession)\n  }\n\n  if (callback) {\n     defer(callback);\n  }\n}\n\n/**\n * Get session from the store.\n * @private\n */\n\nfunction getSession(sessions, sessionId) {\n  var sess = sessions[sessionId]\n\n  if (!sess) {\n    debug('no session in MemoryStore for %s',sessionId);\n    return;\n  }\n\n  // parse\n  sess = JSON.parse(sess)\n\n  var expires = typeof sess.cookie.expires === 'string' ?\n    new Date(sess.cookie.expires) :\n    sess.cookie.expires\n\n  // destroy expired session\n  if (expires && expires <= Date.now()) {\n    debug('Session %s is Expired in MemoryStore',sessionId);\n    delete sessions[sessionId];\n    return;\n  }\n\n  return sess\n}\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/publish/index.js":"// Publish Event API\n// -----------------\n// Allows you to publish events to browser clients. All this code is closely related to the 'event' websocket responder\n'use strict';\n\nvar isInternal,\n  __slice = [].slice,\n  log = require('../utils/log');\n\nmodule.exports = function() {\n  return {\n    transport: require('./transport')(),\n\n    /**\n     * @ngdoc service\n     * @name ss.publish:publish\n     * @description\n     * Extend the internal API with a publish object you can call from your own server-side code\n     * @returns {object} API\n     */\n    api: function(transport) {\n      var methods = {\n\n        /**\n         * @ngdoc function\n         * @name ss.publish#all\n         * @methodOf ss.publish:publish\n         * @param {string} name Name of the event\n         * @param {any} first First parameter (open ended)\n         * @description\n         * Publish event to all active client browsers\n         */\n        all: function() {\n          var event = arguments[0],\n              params = (2 <= arguments.length ? __slice.call(arguments, 1) : []),\n            obj = {\n              t: 'all',\n              e: event,\n              p: params\n            };\n          transport.send(obj);\n          if (!isInternal(event)) {\n            return log.info('➙'.cyan, 'event:all'.grey, event);\n          }\n        },\n        socketId: function() {\n          var socketId = arguments[0],\n              event = arguments[1],\n              params = (3 <= arguments.length ? __slice.call(arguments, 2) : []),\n              obj = {\n                t: 'socketId',\n                socketId: socketId,\n                e: event,\n                p: params\n              };\n          transport.send(obj);\n          return log.info('➙'.cyan, ('event:socketId:' + socketId).grey, event);\n        },\n        users: function() {\n          var users = arguments[0] instanceof Array? arguments[0] : [arguments[0]],\n              event = arguments[1],\n              params = (3 <= arguments.length ? __slice.call(arguments, 2) : []),\n              obj = {\n                t: 'user',\n                users: users,\n                e: event,\n                p: params\n              };\n          transport.send(obj);\n          return log.info('➙'.cyan, ('event:users:[' + (users.join(',')) + ']').grey, event);\n        },\n\n          /**\n           * @ngdoc function\n           * @name ss.publish#channel\n           * @methodOf ss.publish:publish\n           * @param {string|array} channel Name of the channel(s)\n           * @param {string} event Name of the event\n           * @param {any} first First parameter (open ended)\n           * @description\n           * Publish event to all active client browsers in given channel\n           */\n        channels: function() {\n          var channels = arguments[0] instanceof Array? arguments[0] : [arguments[0]],\n              event = arguments[1],\n              params = (3 <= arguments.length ? __slice.call(arguments, 2) : []),\n              obj = {\n                t: 'channel',\n                channels: channels,\n                e: event,\n                p: params\n              };\n          transport.send(obj);\n          return log.info('➙'.cyan, ('event:channels:[' + (channels.join(',')) + ']').grey, event);\n        }\n      };\n\n      // Alias 0.2 command\n      methods.broadcast = methods.all;\n      // Alias singles to plurals\n      methods.channel = methods.channels;\n      methods.user = methods.users;\n\n      // Return all methods\n      return methods;\n    }\n  };\n};\n\n// Private\n\nisInternal = function(event) {\n  return event.substr(0, 5) === '__ss:';\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/publish/transport.js":"// Publish Event Transport\n// -----------------------\n// Right now you can either use the internal transport or inbuilt Redis module\n// The idea behind making this modular is to allow others to experiment with other message queues / servers\n\n'use strict';\n\nmodule.exports = function() {\n  var config, transport;\n  transport = null;\n  config = {};\n  return {\n    use: function(nameOrModule, cfg) {\n      var modPath;\n      if (!cfg) {\n        cfg = {};\n      }\n      config = cfg;\n      transport = (function() {\n        if (typeof nameOrModule === 'function') {\n          return nameOrModule;\n        } else {\n          modPath = './transports/' + nameOrModule;\n          if (require.resolve(modPath)) {\n            return require(modPath);\n          } else {\n            throw new Error('Unable to find Publish Event Transport \\'' + nameOrModule + '\\' internally. Please pass a module');\n          }\n        }\n      })();\n    },\n    load: function() {\n      if (!transport) {\n        this.use('internal');\n      }\n      return transport(config); //TODO should this be (ss,config) ?\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/http/index.js":"'use strict';\n\nvar debug = require('debug')('socketstream:http'),\n    cached = require('./cached'),\n    settings = {           // User-configurable settings with sensible defaults\n      port: 3000,\n      'static': {\n        maxAge: 2592000000    // (30 * 24 * 60 * 60 * 1000) cache static assets in the browser for 30 days\n      },\n      secure: false           // allow setting of the 'secure' cookie attribute when using SSL\n                              // - see https://github.com/socketstream/socketstream/issues/349\n    };\n\n/**\n * @ngdoc service\n * @name http.index:index\n * @function\n *\n * @description\n * HTTP Server\n * -----------\n * SocketStream does not concern itself with web servers. It simply provides a stack of Connect Middleware\n * which can be used by the application in any way it wishes.\n */\nmodule.exports = function(ss) {\n  return {\n    /* Return API */\n    get middleware() {\n      if (!this._middleware) {\n        // Create new Connect app instance which can be accessed from your app.js file with ss.http.middleware\n        this._middleware = ss.require('connect')();\n        this._middleware.use(this.session.middleware);\n        this._middleware.use(this.cached.middleware);\n\n        /* Alias app.use to indicate this will be added to the stack BEFORE SocketStream middleware */\n        this._middleware.prepend = this._middleware.use;\n        this._middleware.append = this._middleware.use;\n        ss.log.warn('ss.http.middleware is deprecated, see socketstream-examples for the new way');\n      }\n      return this._middleware;\n    },\n    set middleware(mw) {\n      debug('Setting SocketStream middleware');\n\n      // express support\n      if (typeof mw.disable === 'function') {\n        mw.disable('x-powered-by');\n      }\n\n      this._middleware = mw;\n    },\n    cached: cached(ss),\n    session: {\n      middleware: sessionMiddleware\n    },\n\n    /**\n     * @ngdoc service\n     * @name http.index:index#set\n     * @methodOf http.index:index\n     * @function\n     *\n     * @description\n     * Merge optional settings\n     *\n     * @param {Object} newSettings Object with settins, @link settings\n     */\n    set: function(newSettings) {\n      var s = '';\n\n      if (typeof newSettings !== 'object') {\n        throw new Error('ss.http.set() takes an object e.g. {static: {maxAge: 60000}}');\n      }\n\n      for (s in newSettings) {\n        if (newSettings.hasOwnProperty(s)) {\n          settings[s] = newSettings[s]\n        }\n      }\n    },\n\n    get settings() {\n      return settings;\n    },\n\n    /**\n     * @ngdoc service\n     * @name http.index:index#load\n     * @methodOf http.index:index\n     * @function\n     *\n     * @description\n     * Attached Middleware, Session store, staticCache, etc, to the this.middleware (`var app = connect()`)\n     */\n    load: function() {\n      this.cached.loadStatic();\n      this.cached.loadAssets();\n      debug('http: loaded.');\n    },\n\n    unload: function() {},\n\n    /**\n     * @ngdoc service\n     * @name http.index:index#route\n     * @methodOf http.index:index\n     * @function\n     *\n     * @description\n     * Expose short-form routing API\n     *\n     * @param  {String}   url Url string for routing\n     * @param  {Function} fn  Callback function for url\n     * @return {Object}       res.serveClient(name) object\n     */\n    route: function(url, fn) {\n      if (fn && typeof fn === 'function') {\n        this.cached.route(url, fn);\n      } else {\n        return {\n          serveClient: (function(name) {\n            this.cached.route(url,function(req, res) {\n              return res.serveClient(name);\n            });\n          }).bind(this)\n        }\n      }\n    }\n  };\n\n  // wrapped to allow using the middleware before the strategy is set\n  function sessionMiddleware(req,res,next) {\n    return ss.session.strategy.sessionMiddleware? ss.session.strategy.sessionMiddleware(req,res,next) : next();\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/http/cached.js":"'use strict';\n/**\n * Ensure that content is up-to-date in edge caches\n */\n\nvar parseurl = require('parseurl'),\n\tdebug = require('debug')('http'),\n\tsend = require('send'),\n\tglob = require('glob'),\n\tpath = require('path');\n\n/*\n Files in static directory are cached and files as is under root.\n\n Files in assets directory are cached and served under `assets/` with their location in the file syste.\n Files ending with .index.html are served as index files.\n\n Known paths are remembered either pointing to a file on the fs or by in memory content.\n */\n\nmodule.exports = function cached(ss) {\n\n\t// known endpoints are cached by path\n\tvar byPath = {};\n\n\tfunction KnownPoint(url, fn, filePath) {\n\t\tthis.url = url;\n    if (fn) { this.handle = fn; }\n    if (filePath) { this.filePath = filePath; }\n\n\t\tbyPath[url] = this;\n\t}\n\n\tKnownPoint.prototype.options = {};\n\n\tKnownPoint.prototype.handle = function(req, res, next) {\n\t\tif (this.content) {\n      // res.statusCode = 303\n\t\t\tres.setHeader('Content-Type', this.mimeType || 'text/plain');\n      res.setHeader('Location', this.url)\n\t\t\tres.end(this.content);\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.filePath) {\n\t\t\tvar stream = send(req, this.filePath, this.options);\n\n\t\t\tif (next) {\n\t\t\t\t// forward non-404 errors\n\t\t\t\tstream.on('error', function error(err) {\n\t\t\t\t\tnext(err.status === 404? null : err);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tstream.pipe(res);\n\t\t\treturn;\n\t\t}\n\n\t\tif (next) { next(); }\n\t};\n\n\tfunction getPoint(req) {\n\t\tvar url;\n\t\tif (typeof req === 'string') {\n\t\t\turl = { path:req, pathname: req };\n\t\t} else {\n\t\t    if (req.method !== 'GET' && req.method !== 'HEAD') {\n\t\t      return null;\n\t\t    }\n\t\t    url = parseurl(req,true);\n\n\t\t}\n\t\tvar point = byPath[url.path] || byPath[url.pathname];\n\t\treturn point;\n\t}\n\n\n\tfunction route(url, fn, filePath) {\n\t\tif (url.charAt(0) !== '/') { url = '/'+url; }\n\t\t// console.log('route defined',url);\n\t\tvar point = getPoint(url);\n\t\tif (point) {\n\t\t\tif (fn) { point.handle = fn; }\n\t\t\tif (filePath) { point.filePath = filePath; }\n\t\t} else {\n\t\t\tpoint = new KnownPoint(url, fn, filePath);\n\t\t\tif (!fn) {\n\t\t\t\tdebug('added known point %s pointing to static file %s',url,filePath);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tget middleware() {\n\t\t\treturn cachedMiddleware;\n\t\t},\n\n\t\troute: route,\n\t\tsend: sendInternal,\n\t\tset: set,\n\n    loadStatic: function() {\n      var assets = path.relative(ss.client.dirs.static,ss.client.dirs.assets);\n      var files = glob.sync('**/*',{cwd:ss.client.dirs.static,nodir:true}).filter(function(p) {\n        //TODO exclude directories\n        return p.indexOf(assets) !== 0;\n      });\n\n      files.forEach(function(url) {\n        route(url,null,path.join(ss.client.dirs.static, url));\n      });\n    },\n\n    loadAssets: function() {\n        var files = glob.sync('**/*',{cwd:ss.client.dirs.assets,nodir:true})\n                      .map(assetPathServed)\n                      .filter(function(p) { return p; }),\n            prefix = '/assets/'; // should this be configurable?\n\n        files.forEach(function(url) {\n          route(prefix+url,null,path.join(ss.client.dirs.assets, url));\n        });\n\t\t\t\tdebug('route ready for assets %s', Object.keys(files))\n\t    }\n    };\n\n    function assetPathServed(filePath) {\n      if (/\\.index\\.html/.test(filePath)) {\n        return path.dirname(filePath);\n      }\n      return filePath; // URL path\n    }\n\n    function sendInternal(url,res) {\n\t\t\tif (url.charAt(0) !== '/') { url = '/'+url; }\n\t\t\tvar point = getPoint(url);\n\t\t\t// console.log(url,res,'sent');\n\t\t\tif (point) {\n\t\t\t\tpoint.handle(res.req, res);\n\t\t\t} else {\n\t\t\t\tss.log.error('Couldn\\'t serve', url);\n\t\t\t}\n    }\n\n    // assumed to be dev time frame, if this is to be used for production it should be enhanced\n    function set(url, content, mimeType) {\n\t\t\tif (url.charAt(0) !== '/') { url = '/'+url; }\n\t\t\tvar point = getPoint(url) || new KnownPoint(url);\n\t\t\t// console.info('new url:',url, mimeType);\n\t\t\tpoint.content = content;\n\t\t\tpoint.mimeType = mimeType;\n    }\n\n\tfunction cachedMiddleware(req, res, next) {\n\t\tvar point = getPoint(req);\n\t\t// console.log('cmw',point,req.url);\n\t\tif (point) {\n\t\t\treturn point.handle(req,res,next);\n\t\t}\n\t\tnext();\n\t}\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/client/index.js":"// Client Asset Manager\n// --------------------\n// The Client Asset Manager allows you to define multiple single-page 'clients' which can be served on\n// different URLs or to different devices. Note: The Client Asset Manager deliberately makes extensive use\n// of synchronous code. This is because all operations only ever run once on startup (when packing the assets)\n// unless you are running in dev mode\n'use strict';\n\nrequire('colors');\n\nvar shortid = require('shortid'),\n    path = require('path'),\n    log = require('../utils/log'),\n    systemAssets = require('./system');\n\n// Set defaults\nvar options = {};\n\nfunction setDefaultOptions(options) {\n\n  // Determine if assets should be (re)packed on startup\n  var packEnv = process.env['SS_PACK'];\n\n  options.packedAssets = packEnv || false;\n\n  options.liveReload = ['code', 'css', 'static', 'templates', 'views'];\n  options.startInBundle = false;\n  options.defaultEntryInit = 'require(\"/entry\");';\n  options.entryModuleName = undefined;\n  options.urls = {\n    assets: '/assets/'\n  };\n  // in 0.5 these will be relative paths\n  options.dirs = {\n    client: '/client',\n    code: '/client/code',\n    system: '/client/code/system', // will be an array after load\n    css: '/client/css',\n    static: '/client/static',\n    assets: '/client/static/assets',\n    templates: '/client/templates',\n    views: '/client/views',\n    workers: '/client/workers'\n  };\n}\n\nsetDefaultOptions(options);\n\n// Store each client as an object\nvar clients = {};\n\n\n/**\n * @ngdoc service\n * @name client\n * @function\n *\n * @description\n * Client serving, bundling, development, building.\n * -----------\n * One or more clients are defined and will be served in production as a single HTML, CSS, and JS file.\n *\n * This is for the module returned by `require('socketstream').client`.\n */\nmodule.exports = function(ss) {\n  // make bundler methods available for default and other implementations\n  ss.bundler = require('./bundler/index')(ss,options);\n\n  // extend http response API\n  // Get hold of the 'response' object so we can extend it later\n  var res = require('http').ServerResponse.prototype;\n\n  // Append the 'serveClient' method to the HTTP Response object\n  res.serveClient = function(name) {\n    ss.http.cached.send('assets/' + name + '/' + clients[name].id + '.html',this);\n  };\n\n  // Alias res.serveClient to keep compatibility with existing apps\n  res.serve = res.serveClient;\n\n  // reloading tracking\n  var lastRun = { updateCSS: {at:Date.now()}, reload: {at:Date.now()} },\n      cssExtensions = ['.css', '.styl', '.stylus', '.less'],\n      consoleMessage = {\n        updateCSS: 'CSS files changed. Updating browser...',\n        reload: 'Client files changed. Reloading browser...'\n      };\n\n  function reloadClients(changedPath,event) {\n     var customOnChange = options.onChange || {},\n         delayTime = customOnChange.delayTime || 100,\n         guardTime = customOnChange.guardTime || 1000;\n\n     function onChangeFiltered(path, event,action) {\n         ss.log.info('✎'.green, consoleMessage[action].grey);\n         var pubs ='__ss:' + action;\n         if (customOnChange.publish) {\n             pubs = options.onChange.publish(path, event,action,pubs);\n         }\n         if (pubs) {\n             ss.publish.all(pubs);\n         }\n\n         lastRun[action].at = Date.now();\n     }\n\n     // reload the browser\n     function onChange(changedPath, event) {\n       var _ref = path.extname(changedPath),\n           action = cssExtensions.indexOf(_ref) >= 0 ? 'updateCSS' : 'reload';\n       //first change is with delayTime delay , thereafter only once there has been no further changes for guardTime seconds\n\n       //validate the change\n       if (customOnChange.validate) {\n           if (!customOnChange.validate(changedPath, event,action)) { return ;} //ignore changes if the app says-so\n       }\n\n       //avoid multiple rapid changes\n       var delay=delayTime;\n       if (lastRun[action].guardTime) { clearTimeout(lastRun[action].guardTime); delay=guardTime;}\n       if (lastRun[action].delayTime) { clearTimeout(lastRun[action].delayTime); delay=delayTime;}\n       lastRun[action].delayTime = setTimeout(function(){\n           onChangeFiltered(changedPath, event, action);\n           lastRun[action].guardTime = setTimeout(function(){\n               lastRun[action].guardTime=null;\n               }, delay);\n            lastRun[action].delayTime=null;\n           }, delay);\n\n       return Date.now();\n     }\n\n     return onChange(changedPath, event);\n  }\n\n  // Return API\n  return {\n    init: function() {\n      this.templateEngine = this.templateEngine || require('./template_engine')(ss,options);\n\n      if (this.formatters == null) {\n        this.formatters = require('./formatters')(ss,options);\n\n        // Load default code formatters\n        this.formatters.add('javascript');\n        this.formatters.add('css');\n        this.formatters.add('html');\n        this.formatters.add('map');\n      }\n\n      systemAssets.load();\n\n      return this;\n    },\n    dirs: {\n      get root() {\n        return path.join(ss.root,options.dirs.client);\n      },\n      get code() {\n        return path.join(ss.root,options.dirs.code);\n      },\n      get system() {\n        return path.join(ss.root,options.dirs.system);\n      },\n      get workers() {\n        return path.join(ss.root,options.dirs.workers);\n      },\n      get css() {\n        return path.join(ss.root,options.dirs.css);\n      },\n      get static() {\n        return path.join(ss.root,options.dirs.static);\n      },\n      get assets() {\n        return path.join(ss.root,options.dirs.assets);\n      },\n      get views() {\n        return path.join(ss.root,options.dirs.views);\n      }\n    },\n\n    /**\n     * @ngdoc service\n     * @name client.formatters:formatters\n     *\n     * @description\n     * This is for the module returned by `require('socketstream').client.formatters`.\n     */\n    formatters: null,\n    /**\n     * @ngdoc service\n     * @name client.templateEngine:templateEngine\n     *\n     * @description\n     * This is for the module returned by `require('socketstream').client.templateEngine`.\n     */\n    templateEngine: null,\n    assets: systemAssets,\n    options: options,\n\n    get faviconPath() {\n      return path.join(ss.root,options.dirs.static,'favicon.ico'); //TODO find the one present\n    },\n\n    // Merge optional options\n    set: function(newOption) {\n      var k, v, y, _results;\n      if (typeof newOption !== 'object') {\n        throw new Error('ss.client.set() takes an object e.g. {liveReload: false}');\n      }\n      _results = [];\n      for (k in newOption) {\n        if (newOption.hasOwnProperty(k)) {\n          v = newOption[k];\n          if (v instanceof Object) {\n            //jshint -W083\n            _results.push((function() {\n              var _results1, x;\n              _results1 = [];\n              for (x in v) {\n                if (v.hasOwnProperty(x)) {\n                  y = v[x];\n\n                  if (!options[k]) {\n                    options[k]= {};\n                  }\n\n                  _results1.push(options[k][x] = y);\n                }\n              }\n              return _results1;\n            })());\n          } else {\n            _results.push(options[k] = v);\n          }\n        }\n      }\n      return _results;\n    },\n\n    servePacked: function(opts) {\n      if (opts && typeof opts !== 'object') {\n        throw new Error('Options passed to ss.client.servePacked() must be an object');\n      }\n      options.servePacked = opts || true;\n      options.liveReload = false;\n    },\n\n    // Tell the asset manager to pack and minimise all assets\n    packAssets: function(opts) {\n      if (opts && typeof opts !== 'object') {\n        throw new Error('Options passed to ss.client.packAssets() must be an object');\n      }\n      options.packedAssets = opts || true;\n      options.servePacked = opts || true;\n      options.liveReload = false;\n\n      // As it's safe to assume we're running in production mode at this point, if your app is not catching uncaught\n      // errors with its own custom error handling code, step in and prevent any exceptions from taking the server down\n      if (options.packedAssets && process.listeners('uncaughtException').length === 0) {\n        return process.on('uncaughtException', function(err) {\n          log.error('Uncaught Exception!'.red);\n          return log.error(err.stack);\n        });\n      }\n    },\n\n    // Define a new Single Page Client\n    /**\n     * @ngdoc service\n     * @name client.define\n     * @function\n     * @param {string} name Logical name of the client\n     * @param {object} paths Paths of css, code, tmpl, view\n     * @returns {{name: *} ClientDefinition} definition Client Definition\n     * @description\n     * Define a client view to serve.\n     *\n     *     ss.http.route('/my-view', function(req,res)\n     *        res.serveClient('my-view');\n     *     });\n     */\n    define: function(name) {\n      if (clients[name]) {\n        throw new Error('Client name \\'' + name + '\\' has already been defined');\n      }\n      // if a function is used construct a bundler with it otherwise use default bundler\n      var client = clients[name] = {\n        name: name,\n        paths: {},\n        uniqueId: shortid.generate(),\n        includes: {\n          css: true,\n          html: true,\n          system: true,\n          initCode: true\n        }\n      };\n      client.id = client.uniqueId;\n\n      ss.bundler.define(client,arguments);\n\n      return client;\n    },\n\n    /**\n     * Standard plugins or ones loaded by require. These plugins do not need to be loaded\n     * in production.\n     * - bundler\n     * - formatter\n     * - template engine\n     */\n    plugins: {},\n\n    /**\n     * @ngdoc service\n     * @name client.task\n     * @function\n     * @param {string} client Name of client\n     * @param {string} name Name of task\n     * @param {string} dependents Array of other client tasks to execute\n     * @param {function} fn Task execution\n     */\n    task: function(client, name, dependents, fn) {\n      // should dependents be translated for other client tasks? Perhaps identify global tasks by a prefix or by lookup\n      dependents = dependents.map(function(task) {\n        return client+':'+task;\n      });\n      ss.tasks.add(client+':'+name, dependents, fn);\n    },\n\n    // experimental interface to reload cache of contents for all clients\n    reloadCached: function() {\n      ss.http.cached.loadStatic();\n      ss.http.cached.loadAssets();\n      ss.bundler.updateCachedOndemandAssets();\n\n      ss.bundler.forEach(function(bundler) {\n        bundler.updateCachedDevAssets();\n      });\n    },\n\n    livereload: {\n      added: function(changedPath) {\n        return reloadClients(changedPath,'added');\n      },\n      changed: function(changedPath) {\n        return reloadClients(changedPath,'changed');\n      },\n      removed: function(changedPath) {\n        return reloadClients(changedPath,'removed');\n      }\n    },\n\n    // experimental interface to reload all clients\n    reloadClients : reloadClients,\n\n    // Listen and serve incoming asset requests\n    load: function() {\n      if (options.servePacked) {\n        ss.bundler.forEach(function(bundler) {\n          bundler.useLatestsPackedId();\n        });\n      }\n      ss.bundler.load();\n      //TODO convert options.dirs to relative paths stripping the lead '/' if present\n\n      // Cache instances of code formatters and template engines here\n      // This may change in the future as I don't like hanging system objects\n      // on the 'ss' internal API object, but for now it solves a problem\n      // we were having when repl.start() would erase vars cached inside a module\n      ss.client.formatters = this.formatters.load();\n      ss.client.templateEngines = this.templateEngine.load();\n    },\n\n    unload: function() {\n      ss.client.formatters = {};\n      ss.client.templateEngines = {};\n      ss.bundler.unload();\n      systemAssets.unload();\n    },\n\n    forget: function() {\n        clients = {};\n        setDefaultOptions(options);\n        systemAssets.unload();\n        ss.bundler.forget();\n        if (this.templateEngine) { this.templateEngine.forget(); this.templateEngine = null; }\n        if (this.formatters) { this.formatters.forget(); this.formatters = null; }\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/client/system/index.js":"'use strict';\n\n// System Assets\n// -------------\n// Loads system libraries and modules for the client. Also exposes an internal API\n// which other modules can use to send system assets to the client\n\nvar fs = require('fs'),\n    pathlib = require('path'),\n    fsUtils = require('../../utils/file');\n\n// Allow internal modules to deliver assets to the browser\nvar assets = exports.assets = {\n  libs: [],\n  modules: {},\n  constants: {},\n  locals: {},\n  startCode: []\n};\n\nfunction pushUniqueAsset(listName,asset) {\n  var list = assets[listName],i;\n  for(i=list.length-1; i>=0; --i) {\n    if (list[i].name === asset.name) {\n      list.splice(i,1);\n    }\n  }\n  return list.push(asset);\n}\n\n/**\n * @ngdoc function\n * @name ss.client:client#send\n * @methodOf ss.client:client\n * @param {'code','lib','module'} type - `code`, `lib`, `module`.\n * @param {string} name - Module name for require.\n * @param {string} content - The JS code\n * @param {Object} options - Allows you to specify `compress` and `coffee` format flags.\n * @description\n * Allow other libs to send assets to the client. add new System Library or Module\n */\n\nvar send = exports.send = function (type, name, content, options) {\n  if (options === null || options === undefined) {\n    options = {};\n  }\n\n  switch (type) {\n    case 'const':\n    case 'constant':\n      //jshint -W093\n      return (assets.constants[name] = {value:content,name:name,type:'const',options:options});\n    case 'local':\n      //jshint -W093\n      return (assets.locals[name] = { value:content,name:name,type:type,options:options});\n    case 'start':\n    case 'code':\n      return assets.startCode.push({content:content,options:options, type:'start'});\n    case 'lib':\n    case 'library':\n      return pushUniqueAsset('libs',{\n        name: name,\n        type: 'lib',\n        dir: pathlib.join(__dirname,'libs'),\n        path: pathlib.join(__dirname,'libs',name + '.js'),\n        content: content,\n        options: options\n      });\n    case 'mod':\n    case 'module':\n      if (assets.modules[name]) {\n        throw new Error('System module name \\'' + name + '\\' already exists');\n      } else {\n        name = name.replace(/\\.js$/,'');\n        assets.modules[name] = {\n          name: name,\n          type: 'mod',\n          dir: pathlib.join(__dirname,'modules'),\n          path: pathlib.join(__dirname,'modules',name + '.js'),\n          content: content,\n          options: options\n        };\n        return assets.modules[name];\n      }\n  }\n};\n\nexports.unload = function() {\n  assets.libs = [];\n  assets.modules = {};\n  assets.constants = {};\n  assets.startCode = [];\n};\n\n// Load all system libs and modules\nexports.load = function() {\n  if (assets.modules['eventemitter2']) {return;}\n  \n  // System Modules. Including main SocketStream client code\n  // Load order is not important\n  var modDir = pathlib.join(__dirname, '/modules');\n  fsUtils.readDirSync(modDir).files.forEach(function(fileName) {\n    var code = fs.readFileSync(fileName, 'utf8');\n    var sp = fileName.split('.');\n    var extension = sp[sp.length - 1];\n    var modName = fileName.substr(modDir.length + 1).replace('.js','').replace('.min.js','');\n    return send('mod', modName, code, {\n      coffee: extension === 'coffee'\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/client/bundler/index.js":"// Client-Side Bundler of assets in development and production\n'use strict';\n\nvar fs = require('fs'),\n    path = require('path'),\n    async = require('async'),\n    debug = require('debug')('socketstream:bundler'),\n    log = require('../../utils/log'),\n    CleanCSS = require('clean-css'),\n    system = require('../system'),\n    glob = require('glob'),\n    uglifyjs = require('uglify-js');\n\n/**\n * {const|local|start|lib|mod} AssetType\n *\n * {'css'|'html'|'worker'|'js'} AssetBundleType\n * @typedef {\n *  name:string,\n *  path:string,\n *  dir:string,\n *  content:string,\n *  options:string,\n *  type:string\n *  } AssetEntry\n */\n\n/**\n * Bundler by client name\n * @type {{}}\n */\nvar bundlers = {},\n    bundlerById = {};\n\nfunction getBundler(client){\n  if (typeof client === \"string\") { return bundlers[client]; }\n\n  if (client.bundler) { return client.bundler; }\n\n  if (client.ts) {\n    if (bundlerById[client.ts]) {\n      return bundlerById[client.ts];\n    }\n  }\n  if (typeof client.client === \"string\") {\n    return bundlers[client.client];\n  }\n  if (typeof client.name === \"string\") {\n    return bundlers[client.name];\n  }\n\n  throw new Error('Unknown client '+(client.name || client.client || client.ts) );\n}\n\n/**\n * @ngdoc service\n * @name bundler\n * @function\n * @description\n * Bundlers included.\n */\n\n/**\n * @ngdoc service\n * @name ss.bundler:bundler\n * @function\n *\n * @description\n * Client bundling API\n * -----------\n * Client bundling API for implementing a custom bundler.\n */\nmodule.exports = function(ss,options) {\n\n  var proto = require('./proto')(ss, bundlers, bundlerById, options),\n      compressor = uglifyjs.Compressor({warnings:false});\n\n  function systemModule(name,wrap) {\n    name = name.replace(/\\.js$/,'');\n    var mod = system.assets.modules[name];\n    if (mod) {\n      var code = wrap===false? mod.content: ss.bundler.wrapModule(name, mod.content);\n      return {\n        file: mod.name,\n        name: mod.name,\n        path: mod.path,\n        dir: mod.dir,\n        content: code,\n        options: mod.options,\n        type: mod.type,\n        includeType: 'system'\n      };\n    }\n  }\n\n  return {\n\n    create: function create(bundler) {\n      var created = Object.create(proto);\n      if (bundler) {\n        for(var key in bundler) {\n          created[key] = bundler[key];\n        }\n      }\n      return created;\n    },\n\n    /**\n     * @ngdoc method\n     * @name ss.bundler:bundler#define\n     * @methodOf ss.bundler:bundler\n     * @function\n     * [Internal] Define the bundler for a client (do not call directly)\n     * @param {string} client object to store the definition in\n     * @param {object} args arguments passed to define\n     */\n    define: function defineBundler(client,args) {\n\n      var name = args[0],\n          pathsOrPlugin = args[1],\n          bundler;\n\n      if (typeof pathsOrPlugin === \"string\") {\n        bundler = bundlers[name] = ss.require(options.servePacked?'production':args[1],'client/bundler','default')(ss,client,options);\n        bundler.client = client;\n        bundler.define(args[2], args[3], args[4], args[5]);\n      } else {\n        bundler = bundlers[name] = require('./default')(ss,client,options); //TODO production bundler switch\n        bundler.client = client;\n        bundler.define(args[1],args[2]);\n      }\n      bundler.useLatestsPackedId();\n    },\n\n    /**\n     * @ngdoc method\n     * @name ss.bundler:bundler#get\n     * @methodOf ss.bundler:bundler\n     * @function\n     * @description\n     * Determine the bundler for a client\n     * @param {object|string} client Query params with client=name or an actual client object\n     */\n    get: getBundler,\n\n    forEach: function(fn,that) {\n      for(var key in bundlers) {\n          var bundler = bundlers[key];\n          fn.call(that,bundler,key);\n      }\n    },\n\n    findEntryPoint: function(client) {\n\n      var firstIndex, // if no entry point, use first index found\n          firstFile;  // if no entry and index, use first file found\n\n      function onlyModuleEntry(f) {\n        return f.substring(0,6) === 'entry.';\n      }\n      function onlyModuleIndex(f) {\n        return f.substring(0,6) === 'index.';\n      }\n      function diskToRequire(rel) {\n        return '/' + rel.replace(/\\\\/g,'/');\n      }\n\n      for(var i = 0,rel; (rel = client.paths.code[i]); ++i) {\n        var p = path.join(ss.root, rel);\n        //TODO if not exists error handling\n        if (fs.existsSync(p) && fs.statSync(p).isDirectory()) {\n\n          var files = fs.readdirSync(p);\n          var entry = files.filter(onlyModuleEntry);\n          if (entry.length) {\n            return diskToRequire(rel) + '/entry';\n          }\n          var index = files.filter(onlyModuleIndex);\n          if (index && !firstIndex) {\n            firstIndex = diskToRequire(rel) + '/';\n          }\n        }\n        else {\n          firstFile = diskToRequire(rel);\n          firstFile = firstFile.substring(0, firstFile.length - path.extname(firstFile).length);\n        }\n      }\n\n      return firstIndex || firstFile;\n    },\n\n    load: function() {\n      var ids = []\n      this.forEach(function(bundler) {\n        bundlerById[bundler.client.id] = bundler;\n        ids.push(bundler.client.id);\n        if (bundler.load) {\n            bundler.load();\n        }\n      });\n      debug('loaded clients %s', ids.join(' '));\n    },\n\n    unload: function() {\n      for(var n in bundlers) {\n        if (bundlers[n].unload) {\n          bundlers[n].unload();\n          bundlers[n].unload = null;\n        }\n      }\n    },\n\n    forget: function() {\n      bundlerById = {};\n      bundlers = {};\n    },\n\n    // API for implementing bundlers\n\n    loadFile: function loadFile(entry, opts, formatter, cb, errCb) {\n      var type = entry.assetType || entry.bundle;\n      formatter = formatter || ss.client.formatters[entry.ext || type];\n      if (!formatter) {\n        throw new Error('Unsupported file extension \\'.' + entry.ext + '\\' when we were expecting some type of ' +\n          ((type||'unknown').toUpperCase()) + ' file. Please provide a formatter for ' + (entry.file) + ' or move it to /client/static');\n      }\n      if (formatter.assetType !== type) {\n        throw new Error('Unable to render \\'' + entry.file + '\\' as this appears to be a ' + (type.toUpperCase()) +\n          ' file. Expecting some type of ' + (type.toUpperCase()) + ' file in ' + (path.dirname(entry.file)) + ' instead');\n      }\n\n      // Use the formatter to pre-process the asset before bundling\n      try {\n        return formatter.call(this.clientFilePath(entry.file), opts, cb, errCb);\n      } catch (err) {\n        return errCb(err);\n      }\n    },\n\n    minifyCSS: function minifyCSS(files) {\n      var origLength = 0;\n      var minified = files.map(function(entry){\n        origLength += entry.content.length;\n        return new CleanCSS().minify(entry.content).styles; // this could also be an async call\n      }).join('\\n');\n      log.info(('  Minified CSS from ' + (formatKb(origLength)) + ' to ' + (formatKb(minified.length))).grey);\n      return minified;\n    },\n\n    minifyJS: function minifyJS_(files) {\n      var that = this;\n      var min = files.map(function(js) {\n        return js.options.minified ? js.content : that.minifyJSFile(js.content);\n      });\n      return min.join('\\n');\n    },\n\n    minifyJSFile: function minifyJSFile(originalCode, fileName) {\n      var ast = uglifyjs.parse(originalCode, { filename:fileName });\n      ast.figure_out_scope();\n      ast = ast.transform(compressor);\n\n      ast.figure_out_scope();\n      ast.compute_char_frequency();\n      ast.mangle_names();\n      var minifiedCode = ast.print_to_string();\n      if (fileName) {\n        log.info(('  Minified ' + fileName + ' from ' + (formatKb(originalCode.length)) + ' to ' + (formatKb(minifiedCode.length))).grey);\n      }\n      return minifiedCode;\n    },\n\n    // input is decorated and returned\n    sourcePaths: function(paths) {\n\n      function relativePath(p, dirType) {\n          var relativeStart = p.indexOf('./') === 0 || p.indexOf('../') === 0;\n          return relativeStart? prefixPath(options.dirs.client,p) : prefixPath(options.dirs[dirType], p);\n      }\n\n      function prefixPath(base,p) {\n          base = base.replace(/^\\//,'');\n          if (p === '*') {\n            return base;\n          }\n          p = p.replace(/\\/\\*$/,'');\n          return path.join(base,p);\n      }\n\n      function entries(from, dirType) {\n        if (from == null) {\n          return [];\n        }\n        var list = (from instanceof Array)? from : [from];\n\n        return list.map(function(value) {\n          return relativePath(value, dirType);\n        });\n      }\n\n      paths.css = entries(paths.css, 'css');\n      paths.code = entries(paths.code, 'code');\n      paths.tmpl = entries(paths.tmpl || paths.templates, 'templates');\n\n      if (paths.view) {\n        paths.view = relativePath(paths.view, 'views');\n      }\n\n      return paths;\n    },\n\n      /**\n       * @ngdoc method\n       * @name ss.bundler:bundler#destsFor\n       * @methodOf ss.bundler:bundler\n       * @function\n       * @description\n       * The define client method of all bundlers must return the file locations for the client.\n       *\n       *     return ss.bundler.destsFor(client);\n       *\n       * To offer a very different way to define the entry-points for assets the bundler can tweak\n       * the paths or replace them.\n       * @param {object} client Object describing the client.\n       * @returns {object} Destinations paths, relPaths, dir, containerDir\n       */\n    destsFor: function(client) {\n      var containerDir = path.join(ss.root, options.dirs.assets);\n      var clientDir = path.join(containerDir, client.name);\n      var assetsUrl = options.urls.assets;\n\n      return {\n\n        //TODO perhaps mixin the abs versions by SS\n        urls: {\n          html: assetsUrl + client.name + '/' + client.id + '.html',\n          js: assetsUrl + client.name + '/' + client.id + '.js',\n          css: assetsUrl + client.name + '/' + client.id + '.css'\n        },\n        paths: {\n          html: path.join(clientDir, client.id + '.html'),\n          js: path.join(clientDir, client.id + '.js'),\n          css: path.join(clientDir, client.id + '.css')\n        },\n        relPaths: {\n          html: path.join(options.dirs.assets, client.name, client.id + '.html'),\n          js: path.join(options.dirs.assets, client.name, client.id + '.js'),\n          css: path.join(options.dirs.assets, client.name, client.id + '.css')\n        },\n        dir: clientDir,\n        containerDir: containerDir\n      };\n    },\n\n    /**\n     @param bundle {String} tmpl/code/css\n     @param file {String} Path relative to project\n     */\n    entryFor: function(bundle,file,part2) {\n      var result = {\n        bundle: bundle,\n        file:file\n      };\n      if (part2) {\n        if (part2.charAt(0) !== '/') {\n          part2 = '/' + part2;\n        }\n        result.file = file + part2;\n      }\n\n      switch(bundle) {\n        case 'tmpl':\n          result.assetType = 'html';\n          break;\n        case 'worker':\n          result.assetType = 'js';\n          break;\n      }\n\n      var extension = path.extname(result.file);\n      result.ext = extension? extension.substring(1) : (result.assetType || result.bundle);\n\n      return result;\n    },\n\n    browserifyLoader: function() {\n      if (!this.browserifyContent) {\n        this.browserifyContent = fs.readFileSync(path.join(__dirname,'browserify.client.js'),'utf8');\n      }\n      return {\n        type: 'mod',\n        file: 'loader',\n        includeType: 'system',\n        names: ['browserify.client.js'],\n        content: this.browserifyContent\n      };\n    },\n\n    /**\n     * @ngdoc method\n     * @name ss.bundler:bundler#systemLibs\n     * @methodOf ss.bundler:bundler\n     * @function\n     * @description\n     * A single entry for all system libraries.\n     *\n     * @returns {AssetEntry} Entry\n     */\n    systemLibs: function() {\n      var names = [];\n      return {\n        type: 'mod',\n        file: 'libs',\n        includeType: 'system',\n        names: names,\n        content: system.assets.libs.map(function(lib) { names.push(lib.name); return lib.content; }).join('\\n')\n      };\n    },\n\n    /**\n     * @ngdoc method\n     * @name ss.bundler:bundler#systemModule\n     * @methodOf ss.bundler:bundler\n     * @function\n     * @description\n     * Describe a system module.\n     *\n     * @param {String} name Name of the system module to return in a descriptor\n     * @param {boolean} wrap Shall the content be wrapped in `require.define`. Default is true.\n     * @returns {AssetEntry} Entry\n     */\n    systemModule: systemModule,\n\n    systemModules: function(wrap) {\n      return Object.keys(system.assets.modules).map(function(name) {\n        return systemModule(name,wrap);\n      });\n    },\n\n    constants: function(client) {\n      var constants = {}, k;\n\n      // mixin system constants\n      for(k in system.assets.constants) {\n        constants[k] = system.assets.constants[k];\n      }\n\n      // mixin client constants\n      if (client.constants) {\n        for(k in client.constants) {\n          constants[k] = describeConstant(k, client.constants[k]);\n        }\n      }\n\n      function describeConstant(key,value) {\n        var desc = { name:key, value:value, type:'constant' };\n        // perhaps add, value = function support\n        return desc;\n      }\n\n      // list of constants\n      var list = [];\n      for(k in constants) {\n        constants[k].content = 'var '+constants[k].name+'='+ JSON.stringify(constants[k].value) +';';\n        list.push(constants[k]);\n      }\n      return list;\n    },\n\n    /**\n     * Default start/init codes to load the client view.\n     *\n     * Called in default bundler startCode.\n     *\n     * @param client Client Object\n     * @returns {[{content: *, options: {}, type:'start'}]} Single Entry for inclusion in entries()\n     */\n    startCode: function(client) {\n      var startCode = system.assets.startCode.map(function(ic) { return ic.content; }),\n        entryInit = client.entryInitPath? 'require(\"' + client.entryInitPath + '\");' : options.defaultEntryInit;\n\n      if (typeof options.entryModuleName === 'string' || options.entryModuleName === null) {\n        entryInit = options.entryModuleName? 'require(\"/'+options.entryModuleName+'\");' : '';\n      }\n\n      startCode.push(entryInit);\n\n      return [{ content: startCode.join('\\n'), options: {}, type: 'start', includeType:'initCode' }];\n    },\n\n    packAssetSet: function packAssetSet(assetType, client, postProcess, done) {\n      var bundler = getBundler(client);\n\n      // if this goes away, drop async dependency. manage with orchestrator?\n      async.mapSeries(bundler.entries(assetType,system.assets), iterator, andThen);\n\n      function iterator(entry, callback) {\n        var options = {\n          constants: bundler.constants(),\n          locals: bundler.locals(),\n          //pathPrefix: entry.importedBy,\n          compress: true\n        };\n        if (typeof entry.content === \"string\") {\n          callback(null, {content:entry.content,options:{}});\n        }\n        else {\n          bundler.asset(entry, options, function(output) {\n            //TODO if err, flag has errors\n            callback(null, {content:output,options:{}});\n          });\n        }\n      }\n\n      function andThen(err, results) {\n        var fileName = bundler.dests.paths[assetType];\n        fs.writeFileSync(fileName, postProcess(results.filter(function(f) { return f.content && f.content !== ';'; })));\n        log.info('✓'.green, 'Packed', results.length, 'files into', bundler.dests.relPaths[assetType]);\n        done();\n      }\n    },\n\n    //TODO task for generating the on-demand stuff to target assets dir\n    //TODO dynamic rule for this, so it can be reapplied when directory changes\n    updateCachedOndemandAssets: function UpdateCachedOndemandAssets() {\n\n      var files = glob.sync('**/*.js', {cwd: path.join(ss.root,options.dirs.code)}); //TODO need root *.js as well\n      files.forEach(function(rel) {\n        ss.http.cached.route('assets/ondemand/'+ (rel.replace('\\\\','/')), null, path.join(ss.root, options.dirs.code, rel) );\n      },this);\n\n      files = glob.sync('**/*.js', {cwd: path.join(ss.root,options.dirs.workers)}); //TODO need root *.js as well\n      files.forEach(function(rel) {\n        ss.http.cached.route('assets/workers/'+ (rel.replace('\\\\','/')), null, path.join(ss.root, options.dirs.workers, rel) );\n      },this);\n    },\n\n    /**\n     * Make a list of asset entries for JS/CSS bundle.\n     *\n     * @param client\n     * @param assetType\n     * @returns {Array}\n     */\n    entries: function entries(client, assetType) {\n\n      var _entries = [],\n          bundler = getBundler(client),\n          includeType,\n          bundle;\n\n      switch(assetType) {\n        case 'css':\n          includeType = 'css';\n          bundle = 'css';\n          client.paths['css'].forEach(pushMainEntries);\n          break;\n\n        case 'js':\n        case 'worker':\n          var loader = bundler.module('loader');\n          var libs = bundler.module('libs');\n          var mods = bundler.module.apply(bundler, Object.keys(system.assets.modules));\n\n          _entries = _entries.concat(loader).concat(libs).concat(mods);\n          includeType = false;\n          bundle = 'js';\n          //TODO worker instead of code ?\n          client.paths.code.forEach(pushMainEntries);\n          if (options.startInBundle) {\n            _entries = _entries.concat(bundler.module('start'));\n          }\n          break;\n\n        case 'tmpl':\n          includeType = 'html';\n          bundle = 'tmpl';\n          client.paths.tmpl.forEach(pushMainEntries);\n          break;\n      }\n\n      function pushMainEntries(from) {\n        var p = path.join(ss.root,from);\n        if (!fs.existsSync(p) || fs.statSync(p).isFile()) {\n          p = from;\n        } else {\n          p = path.join(from,'**','*');\n        }\n        return glob.sync(p, {cwd:ss.root}).forEach(function(file) {\n          var extension = path.extname(file);\n          extension = extension && extension.substring(1); // argh!\n          var assetType = bundle==='tmpl'? 'html':bundle;\n          var entry = {file:file,importedBy:from,includeType:includeType,ext:extension,bundle:bundle,assetType:assetType};\n          if (isAssetType(entry)) {\n            _entries.push(entry);\n          }\n        });\n      }\n\n      function isAssetType(entry) {\n        if (ss.client.formatters == null) {\n          return false;\n        }\n        var formatter = ss.client.formatters[entry.ext];\n        if (formatter == null) {\n          return false;\n        }\n        if (formatter.assetType === undefined) {\n          throw new Error('Unable to render \\''+entry.file+'\\' as the formatter has no asset type.');\n        }\n        return formatter.assetType === entry.assetType;\n      }\n\n      // entries with blank ones stripped out\n      return _entries.filter(function(entry) {\n        return !!entry;\n      });\n    },\n\n    injectTailIfNeeded: function(output,opts) {\n      // If passing optional tails for main view\n      if (opts && opts.tail && !options.startInBundle) {\n        output = output.replace('</body>', opts.tail + '</body>');\n        output = output.replace('</BODY>', opts.tail + '</BODY>');\n      }\n      return output;\n    },\n\n    clientFilePath: function(rel) {\n      if (typeof rel === 'object') {\n        // entry object\n        rel = rel.file;\n      }\n      return path.join(ss.root,rel);\n    },\n\n    formatKb: formatKb,\n\n    wrapModule: function(modPath, code) {\n      return 'require.define(\"' + modPath + '\", function (require, module, exports, __dirname, __filename){\\n' + code + '\\n});'+\n      '';\n            //TODO  '\\n//# sourceMappingURL='+modPath+'.js\\n';\n    }\n\n  };\n};\n\nfunction formatKb(size) {\n  return '' + (Math.round((size / 1024) * 1000) / 1000) + ' KB';\n}\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/client/bundler/proto.js":"'use strict';\n// prototype for bundlers created with ss.bundler.create(..)\n\nvar fs = require('fs'),\n    path = require('path'),\n    shortid = require('shortid'),\n    system = require('../system'),\n    view = require('../view');\n\nvar htmlTag = {\n  css: function(dests,entry) {\n    var url = entry? (dests.urls.css + '?_=' + entry.file) : dests.urls.css;\n    return '<link href=\"' + url + '\" media=\"screen\" rel=\"stylesheet\" type=\"text/css\">';\n  },\n  js: function(dests,entry) {\n    var url = dests.urls.js + '?';\n    switch(entry? entry.type : null) {\n      case null:\n        url = dests.urls.js;\n        break;\n\n      case 'mod':\n      case 'module':\n        url += 'mod='+entry.file;\n        break;\n\n      case 'start':\n        url += 'mod=start';\n        break;\n\n      default:\n        url += '_='+entry.file;\n        break;\n    }\n\n    return '<script src=\"' + url + '\" type=\"text/javascript\"></script>';\n  }\n};\n\n\nmodule.exports = function(ss, bundlers, bundlerById, options) {\n\n  return {\n    /**\n     * @ngdoc method\n     * @name bundler.default:default#load\n     * @methodOf bundler.default:default\n     * @function\n     * @description\n     * Called when the server is started. Does nothing.\n     */\n    load: function() {},\n\n    /**\n     * @ngdoc method\n     * @name bundler.default:default#unload\n     * @methodOf bundler.default:default\n     * @function\n     * @description\n     * Called when the server is stopped. Does nothing.\n     */\n    unload: function() {},\n\n    entries: entries,\n    module: systemModule,\n    toMinifiedCSS: toMinifiedCSS,\n    toMinifiedJS: toMinifiedJS,\n\n    constants: constants,\n    locals: locals,\n    htmlTags: htmlTags,\n\n    updateDests: function() {\n      this.dests = ss.bundler.destsFor(this.client);\n    },\n\n    useLatestsPackedId : function() {\n      if (options.servePacked) {\n        try {\n          this.latestPackedId = false;\n          var files = fs.readdirSync(path.join(ss.root, options.dirs.assets, this.client.name));\n          var latestId = files.sort().pop();\n          var id = latestId.split('.')[0];\n          if (!shortid.isValid(id)) {\n            throw 'Invalid Client ID length';\n          }\n          this.latestPackedId = id;\n          this.packNeeded = false;\n        } catch (e) {\n          this.packNeeded = true;\n        }\n        if (this.latestPackedId) {\n          this.client.id = this.latestPackedId;\n          if (options.packedAssets && options.packedAssets.id) {\n            this.client.id = options.packedAssets.id;\n          }\n        }\n        this.client.id = options.packedAssets.id || this.latestPackedId || this.client.uniqueId;\n\n      } else {\n        this.packNeeded = false;\n        this.client.id = this.client.uniqueId;\n      }\n      this.updateDests();\n    },\n\n    wrapCode: wrapCode,\n\n    format: function(entry, options, formatter,cb, errCb) {\n      ss.bundler.loadFile(entry,options,formatter,cb, errCb); //TODO call loadFile 'html'\n    },\n\n    updateCachedDevAssets: UpdateCachedDevAssets,\n\n    clientFilePath: function(rel) {\n      return ss.bundler.clientFilePath(rel);\n    },\n\n    entryFor: function(bundle,file) {\n      return ss.bundler.entryFor(bundle,file);\n    }\n  };\n\n  // When packing assets the default path to the CSS or JS file can be overridden\n  // either with a string or a function, typically pointing to an resource on a CDN\n  function resolveAssetLink(client, type) {\n    var defaultPath = '/assets/' + client.name + '/' + client.id + '.' + type,\n      pack = options.packedAssets,\n      link = pack !== undefined ? (pack.cdn !== undefined ? pack.cdn[type] : void 0) : void 0;\n    if (link) {\n      if (typeof link === 'function') {\n        var file = {\n          id: client.id,\n          name: client.name,\n          extension: type,\n          path: defaultPath\n        };\n        return link(file);\n      } else if (typeof link === 'string') {\n        return link;\n      } else {\n        throw new Error('CDN ' + type + ' param must be a Function or String');\n      }\n    } else {\n      return defaultPath;\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @name bundler.default:default#entries\n   * @methodOf bundler.default:default\n   * @function\n   * @description\n   * Provides the view and the pack functions with a\n   * list of entries for an asset type relative to the client directory.\n   * The default implementation is used.\n   *\n   * An entry describes:\n   * - file: source file name relative to client directory\n   * - importedFrom: Pulled in by require in other file\n   * - content: If pre-loaded\n   * - type: If system asset it will have type lib/mod\n   * - bundle: which production bundle (html, tmpl, css, js, worker)\n   * - assetType: css, js, html\n   * - extension: source file extension\n   *\n   * @param {String} assetType js/css/tmpl\n   * @param {Object} systemAssets Collection of libs, modules, initCode\n   * @returns {[AssetEntry]} List of output entries\n   */\n  function entries(assetType,systemAssets) {\n    // jshint validthis:true\n    var includes = this.client.includes;\n    return ss.bundler.entries(this.client, assetType, systemAssets).filter(function(entry) {\n      return entry.includeType? includes[entry.includeType] : true;\n    });\n  }\n\n  /**\n   * @ngdoc method\n   * @name bundler.default:default#system\n   * @methodOf bundler.default:default\n   * @function\n   * @description\n   * Return entries for the loader/start/module depending on includes.system client config and system assets.\n   * Multiple arguments will attempt to add module for the name.\n   * Special module names are 'loader' and 'start'.\n   *\n   * @returns {AssetEntry} Resource entries array\n   */\n  function systemModule(/* first_name */) {\n    var entries = [],\n        // jshint validthis:true\n        client = this.client;\n\n    /*jshint -W084 */\n    for(var i= 0,name; name = arguments[i]; ++i) {\n      switch(name) {\n        case 'loader':\n          entries.push(ss.bundler.browserifyLoader());\n          break;\n        case 'libs':\n          entries.push(ss.bundler.systemLibs());\n          break;\n        case 'start':\n          entries = entries.concat(ss.bundler.constants(client));\n          if (client.includes.initCode) {\n            entries = entries.concat(ss.bundler.startCode(client));\n          }\n          break;\n\n        //case \"eventemitter2\":\n        //case \"socketstream\":\n        default:\n          entries.push(ss.bundler.systemModule(name));\n          break;\n      }\n    }\n\n    return entries;\n  }\n\n  function constants() {\n    var result = {}, k;\n\n    // mixin system constants\n    for(k in system.assets.constants) {\n      result[k] = system.assets.constants[k].value;\n    }\n\n    // mixin client constants\n    // jshint validthis:true\n    var client = this.client;\n    if (client.constants) {\n      for(k in client.constants) {\n        result[k] = client.constants[k];\n      }\n    }\n\n    return result;\n  }\n\n  function locals() {\n    var result = {}, k;\n\n    // mixin system locals\n    for(k in system.assets.locals) {\n      result[k] = system.assets.locals[k].value;\n    }\n\n    // mixin client constants\n    // jshint validthis:true\n    var client = this.client;\n    if (client.locals) {\n      for(k in client.locals) {\n        result[k] = client.locals[k];\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * @ngdoc method\n   * @name bundler.default:default#htmlTags\n   * @methodOf bundler.default:default\n   * @function\n   * @description\n   * Function called by view.js to build the view HTML\n   *\n   *\n   * @param {String} type Either start/js/css\n   * @param {Boolean} pack Pack with resolveAssetLink ?\n   * @returns {[String]} List of script tag strings\n   */\n  function htmlTags(type,pack) {\n    var dests;\n\n    // jshint validthis:true\n    if (type === 'start') {\n      return ['<script>' + this.module('start').map(function(value) { return value.content; }).join('\\n') + '</script>'];\n    }\n\n    if (pack) {\n      dests = { urls: {} };\n      // jshint validthis:true\n      dests.urls[type] = resolveAssetLink(this.client, type);\n      return [ htmlTag[type](dests) ];\n    } else {\n      // jshint validthis:true\n      var entries = this.entries(type);\n      dests = this.dests;\n      return entries.map(function(entry) {\n        return htmlTag[type](dests,entry);\n      });\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @name bundler.default:default#wrapCode\n   * @methodOf bundler.default:default\n   * @function\n   * @description\n   * Before client-side code is sent to the browser any file which is NOT a library (e.g. /client/code/libs)\n   * is wrapped in a module wrapper (to keep vars local and allow you to require() one file in another).\n   *\n   * The 'system' directory is a special case - any module placed in this dir will not have a leading slash\n   *\n   * @param {String} assetType js/css/tmpl\n   * @param {Object} systemAssets Collection of libs, modules, initCode\n   * @returns {[AssetEntry]} List of output entries\n   */\n  function wrapCode(code, entry, opts) {\n    var pathAry = entry.file.split('/');\n\n    // Don't touch the code if it's in a 'libs' directory\n    if (pathAry.indexOf('libs') >= 0) { //TODO [code,libs] & options.dirs.libs location\n      return code;\n    }\n\n    // if it's configured in excludes, return raw code\n    if (pathAry.indexOf('entry.js') === -1 && options && options.browserifyExcludePaths) {\n      for(var i, p; (p = options.browserifyExcludePaths[i]); ++i) {\n        if ( entry.file.split( p )[0] === '' ) {\n          return code;\n        }\n      }\n    }\n\n    var last = pathAry[pathAry.length-1],\n      modPath,\n      extPos = last.lastIndexOf('.');\n    if (extPos > -1) {\n      pathAry[pathAry.length-1] = last.substring(0,extPos);\n    }\n\n    //TODO configurable system locations with array instead of string\n    // Don't add a leading slash if this is a 'system' module\n    if (entry.file.indexOf(options.dirs['system'].substring(1)) === 0) { //TODO [code,system] & improve test to allow parallel system dir\n      // Take everything after the /system/ part of the path\n      modPath = pathAry.slice(pathAry.indexOf('system')+1).join('/');\n    } else {\n\n      // Otherwise treat as a regular module\n      modPath = pathAry.join('/');\n\n      // Work out namespace for module\n      if (opts.pathPrefix) {\n\n        // Ignore any filenames in the path\n        if (opts.pathPrefix.indexOf('.') > 0) {\n          var sp = opts.pathPrefix.split('/');\n          sp.pop();\n          opts.pathPrefix = sp.join('/');\n        }\n        modPath = '/' + path.substr(opts.pathPrefix.length + 1);\n      } else {\n        modPath = '/' + modPath;\n      }\n    }\n    return ss.bundler.wrapModule(modPath, code);\n  }\n\n  function UpdateCachedDevAssets() {\n    var url = 'assets/'+this.client.name+'/'+this.client.id+'.html';\n    view(ss, this.client, options, function(content) {\n      ss.http.cached.set(url, content, 'text/html; charset=utf-8');\n    });\n\n    var common = {\n      constants: this.constants(),\n      locals: this.locals(),\n      client: this.client.name,\n      clientId: this.client.id\n    };\n\n    this.entries('css').forEach(function(entry) {\n      this.asset(entry, common, function(output) {\n        url = 'assets/'+this.client.name+'/'+this.client.id+'.css?_='+entry.file;\n        ss.http.cached.set(url, output, 'text/css; charset=utf-8');\n      }.bind(this));\n    },this);\n\n    var modules = {};\n\n    this.entries('js').forEach(function(entry) {\n      if (entry.type === 'mod') {\n        this.module(entry.file).forEach(function(mod) {\n          modules[entry.file] = modules[entry.file] || [];\n          modules[entry.file].push(mod.content);\n        });\n      } else {\n        this.asset(entry, common, function(output) {\n          url = 'assets/'+this.client.name+'/'+this.client.id+'.js?_='+entry.file;\n          ss.http.cached.set(url, output, 'text/js; charset=utf-8');\n        }.bind(this));\n      }\n    },this);\n\n    for(var n in modules) {\n      var output = modules[n].join('\\n');\n          url = 'assets/'+this.client.name+'/'+this.client.id+'.js?mod='+n;\n      ss.http.cached.set(url, output, 'text/js; charset=utf-8');\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @name bundler.default:default#toMinifiedCSS\n   * @methodOf bundler.default:default\n   * @function\n   * @description\n   * Minify JavaScript using CleanCSS\n   *\n   * @param {Array} files Entries with file path and content to be minified\n   * @returns {String} Minified content\n   */\n  function toMinifiedCSS(files) {\n    return ss.bundler.minifyCSS(files);\n  }\n\n  /**\n   * @ngdoc method\n   * @name bundler.default:default#toMinifiedJS\n   * @methodOf bundler.default:default\n   * @function\n   * @description\n   * Minify JavaScript using Uglify\n   *\n   * @param {Array} files Entries with file path and content to be minified\n   * @returns {String} Minified content\n   */\n  function toMinifiedJS(files) {\n    return ss.bundler.minifyJS(files);\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/client/view.js":"// Client Views\n// ------------\n// Generates HTML output for each single-page view\n'use strict';\n\nmodule.exports = function(ss, client, options, cb) {\n  var templateEngine = require('./template_engine')(ss, options), //TODO why not use the one in client/index ?\n      bundler = ss.bundler.get(client);\n\n  function templates() {\n    var files = bundler.entries('tmpl'),\n        output = [];\n    templateEngine.generate(bundler, files, function(html) {\n      return output.push(html);\n    });\n    return output;\n  }\n\n  function headers() {\n    // Return an array of headers. Order is important!\n    var output = [];\n\n    // Send all CSS\n    if (client.includes.css) {\n      output = output.concat( bundler.htmlTags('css',!!client.pack) );\n    }\n\n    // Send Application Code\n    output = output.concat( bundler.htmlTags('js',!!client.pack) );\n\n    return output;\n  }\n\n  // Add links to CSS and JS files\n  var includes = headers().concat(templates());\n\n  // In future constants might be placed at beginning of headers\n  var start = bundler.htmlTags('start');\n  if (options.startInBundle) {\n    includes = includes.concat(start);\n    start = [];\n  }\n\n  // Output HTML\n  var htmlOptions = {\n    constants: bundler.constants(),\n    locals: bundler.locals(),\n    headers: includes.join(''),\n    tail: start.join(''),\n    compress: options.packedAssets,\n    filename: client.paths.view\n  };\n  return bundler.asset(bundler.entryFor('html',client.paths.view), htmlOptions, cb);\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/client/template_engine.js":"// Template Engine\n// ---------------\n// By default client-side templates are concatted and sent to the client using the 'default' wrapper\n// (a basic script tag with an ID generated from the file path). However you can easily specify your own template\n// engine in your app.js file with the ss.client.templateEngine.use() command\n// You may combine several types of template engines together - very useful when converting a site from one format\n// to another, or experimenting with different template engines\n'use strict';\n\nrequire('colors');\n\nvar path = require('path'),\n    client = require('./system');\n\n// Allow Template Engine to be configured\nmodule.exports = function(ss,options) {\n  var mods = [];\n\n  // Set the Default Engine - simply wraps each template in a <script> tag\n  var defaultEngine = require('./template_engines/default')(ss.root,null,options);\n\n  return {\n\n    /**\n     * @ngdoc function\n     * @name client.templateEngine:templateEngine#use\n     * @methodOf client.templateEngine:templateEngine\n     * @param {string|Function} name - Built-in templating engine or function making the enging.\n     * @param {Array} dirs - Directories to use template for (optional)\n     * @param {Object} config - Config passed to the template engine.\n     * @description\n     * Use a template engine for the 'dirs' indicated (will use it on all '/' dirs within /client/templates by default)\n     *\n     * To make templates in `/client/ember-view` available in Ember.\n     *\n     *     ss.client.templateEngine.use('ember','./ember-view');\n     *\n     * To make templates in `/client/angular-view` available in Angular.\n     *\n     *     ss.client.templateEngine.use('angular','./angular-view');\n     *\n     * To make templates in `/client/templates/angular-view` available in Angular.\n     *\n     *     ss.client.templateEngine.use('angular','/angular-view');\n     *\n     * To make templates anywhere in `/client` available in Angular.\n     *\n     *     ss.client.templateEngine.use('angular','/');\n     *\n     * To make templates anywhere in `/client` available using a custom engine.\n     *\n     *     ss.client.templateEngine.use(require('custom-engine'));\n     *\n     * To make templates anywhere in `/client/custom` available using a custom engine.\n     *\n     *     ss.client.templateEngine.use(require('custom-engine'),'./custom');\n     */\n    use: function(nameOrModule, dirs, config) {\n      if (!dirs) {\n        dirs = ['.'];\n      }\n      if (!(dirs instanceof Array)) {\n        dirs = [dirs];\n      }\n\n      dirs = dirs.map(function(dir) {\n        if (dir === '/') {\n          return '.';\n        }\n        if (dir.charAt(0) === '/') {\n          return path.join(options.dirs.templates.substring(1), dir.substring(1));\n        }\n        return path.join(options.dirs.client.substring(1), dir);\n      });\n\n      var mod = ss.require(nameOrModule, 'client/template_engines', function(err) {\n        throw new Error('The ' + err.id + ' template engine is not supported by SocketStream internally '+\n          'or found in the project packages. Please pass a compatible module instead');\n      });\n      var engine;\n      if (typeof mod === 'function') {\n        engine = mod(ss, config, options);\n      } else {\n        engine = mod.init(ss, config, options);\n      }\n      return mods.push({\n        engine: engine,\n        dirs: dirs\n      });\n    },\n    load: function() {\n      var templateEngines = {};\n      mods.forEach(function(mod) {\n        return mod.dirs.forEach(function(dir) {\n          templateEngines[dir] = mod.engine;\n          return templateEngines[dir];\n        });\n      });\n      return templateEngines;\n    },\n\n    forget: function() {\n      mods.length = 0;\n    },\n\n    //TODO the default IDs for templates are best relative to client (or project root?)\n\n    /**\n     * @ngdoc function\n     * @name client.templateEngine:templateEngine#generate\n     * @methodOf client.templateEngine:templateEngine\n     * @param {Object} bundler - Bundler instance for client.\n     * @param {Array} files - Entries for the templates to render markup for.\n     * @param {Function} cb - Callback to receive the string output or Error object.\n     * @description\n     * Generate output (as a string) from Template Engines\n     *\n     *     function(out) {\n     *       if (typeof out === 'string') {\n     *       } else {\n     *       // error object\n     *       }\n     *     }\n     */\n    generate: function(bundler, files, cb) {\n      var prevEngine = null;\n      var templates = [];\n      if (!(files && files.length > 0)) {\n        cb('');\n      }\n      return files.forEach(function(desc) {\n        // Work out which template engine to use, based upon the path (TODO split file.sep)\n        var engine = selectEngine(desc.file) || defaultEngine;\n\n        var formatter;\n        if (engine.selectFormatter) {\n          formatter = engine.selectFormatter(desc.file, ss.client.formatters, null);\n        }\n\n        var opts = {\n          constants: bundler.constants(),\n          locals: bundler.locals()\n        };\n\n        return bundler.format(desc,\n          opts, formatter, function(output) {\n\n          templates.push(wrapTemplate(output, desc.file, ss.bundler.clientFilePath(desc), opts, options, engine, prevEngine));\n          prevEngine = engine;\n\n          // Return if last template\n          if (templates.length === files.length) {\n            output = templates.join('');\n            if (engine !== null && engine.suffix) {\n              output += engine.suffix();\n            }\n            return cb(output);\n          }\n        }, function(err) {\n          ss.log.clientIssue(client,options,err,desc);\n          return cb('Couldn\\'t format ' + desc.file + err.userInfoHTML);\n        });\n      });\n    }\n  };\n\n  // private\n\n  function selectEngine(p) {\n    var codePath = path.dirname(p); // remove the file name or child directory in recursive call\n    var engine = ss.client.templateEngines[codePath];\n\n    if (engine) {\n      return engine;\n    }\n    if (codePath !== '.') {\n      return selectEngine(codePath || '.');\n    }\n  }\n\n  function wrapTemplate(template, pth, logicPath, opts, options, engine, prevEngine) {\n    var output;\n    output = [];\n\n    // If the template type has changed since the last template, include any closing suffix from the last engine used (if present)\n    if (prevEngine && prevEngine !== engine && prevEngine.suffix) {\n      output.push(prevEngine.suffix());\n    }\n\n    // If this is the first template of this type and it has prefix, include it here\n    if ((prevEngine === null || prevEngine !== engine) && engine.prefix) {\n      output.push(engine.prefix());\n    }\n\n    // Add main template output and return\n    output.push(engine.process(template.toString(), logicPath, suggestedId(pth, options.dirs.templates.substring(1)), opts));\n    return output.join('');\n  }\n\n  // This should be on the bundler entries, so it can be tweaked by bundler before being used by the engine\n  // Suggest an ID for this template based upon its path\n  // 3rd party Template Engine modules are free to use their own naming conventions but we recommend using this where possible\n  function suggestedId(pth, templatesPath) {\n    if (pth.indexOf(templatesPath) === 0) {\n      pth = pth.substring(templatesPath.length + 1);\n    }\n    var sp;\n    sp = pth.split('.');\n    if (pth.indexOf('.') > 0) {\n      sp.pop();\n    }\n    return sp.join('.').replace(/\\//g, '-');\n  }\n};\n\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/client/template_engines/default.js":"// Default Engine produces standard <script> tags which can be used with jQuery Templates and uncompiled\n// Hogan/Mustache templates among many others.\n// Note all templates are prefixed with 'tmpl-' to prevent conflicts with DOM IDs in your application\n'use strict';\n\nmodule.exports = function() {\n  return {\n    name: 'Default',\n    process: function(template, path, id) {\n      return '<script id=\"tmpl-' + id + '\" type=\"text/x-tmpl\">' + template + '</script>';\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/client/formatters.js":"// Code Formatters\n// ---------------\n// Loads default code formatters and presents an API for loading custom formatters\n'use strict';\nvar debug = require('debug')('socketstream:client');\n\n/**\n * @ngdoc service\n * @name client.formatters:formatters\n * @description\n * Formatter registry\n */\nmodule.exports = function(ss,options) {\n  var mods = [];\n  return {\n    /**\n     * @ngdoc method\n     * @name client.formatters:formatters#add\n     * @methodOf client.formatters:formatters\n     * @function\n     * Define a formatter for client asset (JS/CSS/HTML) rendering\n     * @param {string|object} nameOrModule the formatter object or name\n     * @param {object} config parameters configuring the formatter\n     */\n    add: function(nameOrModule, config) {\n      var formatter;\n      config = config || {};\n      switch(typeof nameOrModule) {\n        case 'object':\n          formatter = nameOrModule.init(ss.root, config, options);\n          addCall(formatter);\n          break;\n\n        case 'function':\n        case 'string':\n          var mod = ss.require(nameOrModule, 'client/formatters',function(err) {\n            throw new Error('The \"'+err.id+'\" formatter is not supported by '+\n                    'SocketStream internally. Please pass a compatible module instead');\n          });\n          formatter = mod(ss, config, options);\n          addCall(formatter,true);\n          break;\n      }\n\n      return mods.push(formatter);\n    },\n    load: function() {\n      var byExtension = {};\n      mods.forEach(function (mod) {\n        return mod.extensions.forEach(function (extension) {\n          byExtension[extension] = mod;\n        });\n      });\n      debug('Formatters supported by extension: %s', Object.keys(byExtension).join(','));\n      return byExtension;\n    },\n    forget: function() {\n      mods.length = 0;\n    }\n  };\n\n  function addCall(formatter) {\n    formatter.call = function(path,options,cb,errCb) {\n      try{\n        formatter.compile(path,options,function(result) {\n          if (typeof result === 'string') { return cb(result); }\n          else { return errCb(result); }\n        },errCb);\n      }\n      catch(ex) {\n        return errCb(ex);\n      }\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/client/formatters/javascript.js":"'use strict';\n\nvar fs = require('fs');\n\n/**\n * Javascript formatter\n */\nmodule.exports = function(ss) {\n  return {\n    extensions: ['js'],\n    assetType: 'js',\n    contentType: 'text/javascript; charset=utf-8',\n    compile: function(path, options, cb) {\n      ss.log.trace('Compiling plain JS',path,options);\n      //TODO if no file, return error object\n      return cb(fs.readFileSync(path, 'utf8'));\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/client/formatters/css.js":"'use strict';\n\nvar fs = require('fs');\n\n/**\n * Plain CSS Formatter\n */\nmodule.exports = function(ss) {\n  return {\n    extensions: ['css'],\n    assetType: 'css',\n    contentType: 'text/css',\n    compile: function (path, options, cb) {\n      ss.log.trace('Compiling plain CSS',path,options);\n      //TODO if no file, return error object\n      return cb(fs.readFileSync(path, 'utf8'));\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/client/formatters/html.js":"'use strict';\n\nvar fs = require('fs');\n\n/**\n * Plain HTML Formatter\n */\nmodule.exports = function(ss) {\n  return {\n    extensions: ['html'],\n    assetType: 'html',\n    contentType: 'text/html',\n    compile: function(path, options, cb) {\n      ss.log.trace('Compiling plain HTML',path,options);\n      var input;\n      input = fs.readFileSync(path, 'utf8');\n      //TODO if no file, return error object\n\n      // If passing optional headers for main view\n      if (options && options.headers) {\n        input = input.replace('<SocketStream>', options.headers);\n        input = input.replace('<SocketStream/>', options.headers);\n      }\n      return cb(input);\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/client/formatters/map.js":"// JS Minmap formatter\n//\n// courtesy of Waxolunist (gh)\n//\n'use strict';\n\n\n\n// Dependencies\n//\nvar fs = require('fs');\n\nmodule.exports = function(ss) {\n\n  return {\n    extensions: ['map'],\n    assetType: 'js',\n    contentType: 'application/json',\n    compile: function(path, options, cb) {\n      ss.log.trace('Compiling plain MAP',path,options);\n      //TODO if no file, return error object\n      return cb(fs.readFileSync(path, 'utf8'));\n    }\n  };\n\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/tasks/index.js":"'use strict';\n\nvar log = require('../utils/log'),\n    liveReload = require('./live_reload'),\n    Orchestrator = require('orchestrator'),\n    orchestrator = new Orchestrator();\n\nmodule.exports = function(ss, options) {\n\n  orchestrator.on('err', function(err) {\n    if (typeof err === 'object') {\n      err = err.err;\n    }\n    if (ss.env === 'production') {\n      ss.log.error(err.message); //TODO production error handling strategy\n    } else {\n      ss.log.error('tasks failed, %s: %s', err.message, err.stack);\n    }\n  });\n\n  return {\n    plan: function(args) {\n      var plan = {}, httpServer = args[0];\n      plan.targets = Array.prototype.slice.call(args);\n      if (args.length === 0 || typeof httpServer === 'string' || httpServer instanceof Array) {\n        plan.httpServer = null;\n      } else {\n        plan.httpServer = httpServer;\n        plan.targets.shift();\n      }\n      var last = plan.targets[plan.targets.length-1];\n      if (typeof last === 'function') {\n        plan.callback = last;\n        plan.targets.pop();\n      }\n      if (plan.targets[0] instanceof Array) {\n        plan.targets = plan.targets[0];\n      }\n      if (plan.targets.length === 0) {\n        plan.targets.push('default');\n      }\n\n      return plan;\n    },\n\n    add: task,\n    defaultTask: defaultTask,\n\n    defaults: require('./defaults')(ss, options, orchestrator),\n    orchestrator:orchestrator, // this is mostly for testing\n\n    _packTasks: function(all) {\n      var tasks = all? ['load-api']:['pack-prepare','load-api'];\n      ss.bundler.forEach(function(bundler){\n        if (all) {\n          tasks.push(bundler.client.name + ':pack');\n        } else if (bundler.packNeeded) {\n          tasks.push(bundler.client.name + ':pack-needed');\n          tasks.push(bundler.client.name + ':pack');\n        } else {\n          tasks.push(bundler.client.name + ':pack-unneeded');\n        }\n      });\n      return tasks;\n    },\n\n    unload: function() {\n      liveReload.unload();\n    },\n\n    forget: function() {\n      for(var n in orchestrator.tasks) {\n        delete orchestrator.tasks[n];\n      }\n    },\n\n    use: function(gulp) {\n      orchestrator = this.orchestrator = gulp;\n      return this;\n    },\n\n    start: function(tasks, done) {\n      orchestrator.start(tasks, doneIfAllDone);\n      return this;\n\n      function doneIfAllDone(err) {\n        if (err) {\n          log.error('!'.red, 'task failed', err);\n        }\n\n        if (!orchestrator.isRunning && done) {\n          done(err);\n        }\n      }\n    },\n    on: function() {\n      orchestrator.on.apply(orchestrator,arguments);\n      return this;\n    }\n  };\n\n  function task(name, dependents, fn) {\n    orchestrator.add(name, dependents, fn);\n  }\n\n  function defaultTask(name, dependents, fn) {\n    if (!orchestrator.hasTask(name)) {\n      orchestrator.add(name, dependents, fn);\n    }\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/tasks/live_reload.js":"// Live Reload\n// -----------\n// Detects changes in client files and sends an event to connected browsers instructing them to refresh the page\n'use strict';\n\nrequire('colors');\n\nvar watcher,\n    debug = require('debug')('socketstream:reload');\n\nmodule.exports = function(ss, options) {\n\n  var pathlib = require('path'),\n      chokidar = ss.require('chokidar');\n\n  var watchDirs = (function() {\n    var _i, _len, _ref, _results;\n    _ref = options.liveReload;\n    _results = [];\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      var dir = _ref[_i];\n      _results.push(pathlib.join(ss.root, options.dirs[dir] || dir));\n    }\n    return _results;\n  })();\n\n  watcher = chokidar.watch(watchDirs, {\n    ignoreInitial: true,\n    ignored: /(\\/\\.|~$)/\n  });\n  watcher.on('add', function(path) {\n    debug('added: %s',path);\n    return ss.livereload.added(path);\n  });\n  watcher.on('change', function(path) {\n    debug('added: %s',path);\n    return ss.livereload.changed(path);\n  });\n  watcher.on('unlink', function(path) {\n    debug('added: %s',path);\n    return ss.livereload.removed(path);\n  });\n  watcher.on('error', function(error) {\n    return ss.log.error('✎'.red, ('Error: ' + error).red);\n  });\n};\n\nmodule.exports.unload = function() {\n  if (watcher) {\n    watcher.close();\n    watcher = null;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/tasks/defaults.js":"'use strict';\n\nvar fs = require('fs'),\n    path = require('path'),\n    debug = require('debug')('socketstream'),\n    socketstream = require('../socketstream'),\n    log = require('../utils/log'),\n    view = require('../client/view'),\n    liveReload = require('./live_reload');\n\nmodule.exports = function(ss, options, orchestrator) {\n\n  return function() {\n    ss.defaultTask('application', function() {});\n\n    ss.defaultTask('start-server',['application'],function(done) {\n      socketstream.ws.listen(ss.http.settings.port || 3000, done);\n    });\n\n    ss.defaultTask('load-api', function() {\n      ss.load();\n    });\n\n    ss.defaultTask('test-socketstream', ['load-api'], function() {\n      var sessionID = ss.session.create();\n\n      // jshint loopfunc:true\n      for (var id in ss.server.responders) {\n        if (ss.server.responders.hasOwnProperty(id)) {\n          var responder = ss.server.responders[id];\n\n          if (responder.name && responder.interfaces.internal) {\n            var fn = function(){\n              var args = Array.prototype.slice.call(arguments),\n                  cb = args.pop();\n\n              return responder.interfaces.internal(args, {sessionId: sessionID, transport: 'test'}, function(err, params){ cb(params); });\n            };\n            ss.add(responder.name, fn); // interesting, potential or hack?\n          }\n        }\n      }\n    });\n\n    // task: ondemand\n    // Listen out for requests to async load new assets\n    ss.defaultTask('serve', function serveOndemand(done) {\n      ss.bundler.updateCachedOndemandAssets(); //TODO pipe to cache\n\n      socketstream.ws.listen(ss.http.settings.port || 3000);\n\n      // Send server instance to any registered modules (e.g. console)\n      ss.events.emit('server:start', ss.server);\n\n      process.on('exit', function() {\n        if (done) {\n          done();\n        }\n        ss.events.emit('server:stop', ss.server);\n        if (orchestrator.hasTask('stop-server')) {\n            orchestrator.start('stop-server',function() {\n              ss.server = null;\n            });\n        }\n      });\n    });\n\n    ss.defaultTask('live-assets', function() {\n      ss.load();\n      //TODO ss.started promise to wait for. resolved when streaming server is started\n      ss.bundler.forEach(function(bundler) {\n        bundler.updateCachedDevAssets();\n      });\n    });\n\n    ss.defaultTask('live-reload', function() {\n      liveReload(ss, options);\n    });\n\n    ss.defaultTask('stop-server', function() {\n      if (ss.server.httServer) {\n        ss.server.httServer.close(); //TODO do it on ss.ws\n        debug('stopped http server.');\n      }\n    });\n\n    var defaultDeps = [];\n\n    if (options.packedAssets) {\n      defaultDeps.push(options.packedAssets.all? 'pack-all':'pack-if-needed');\n    } else if (!options.servePacked) {\n      defaultDeps.push('live-assets');\n    }\n    if (options.liveReload) {\n      defaultDeps.push('live-reload');\n    }\n    // if (httpServer)\n    defaultDeps.push('serve');\n\n    ss.defaultTask('default',defaultDeps);\n\n    ss.bundler.forEach(function(bundler) {\n      var name = bundler.client.name;\n      ss.defaultTask(name+':pack-unneeded', function() {\n        log.info('✓'.green, ('Serving client \\'' + name + '\\' using pre-packed assets (ID ' +\n            bundler.client.id + ')').grey);\n      });\n      ss.defaultTask(name+':pack-needed', function() {\n        log.info('!'.red, ('Unable to find pre-packed assets for \\'' +\n            name + '\\'. All assets will be repacked').grey);\n      });\n      ss.defaultTask(name+':pack-prepare', function(done) {\n        bundler.client.pack = true;\n        log.info(('Pre-packing and minifying the \\'' + name + '\\' client...').yellow);\n\n        // Prepare folder\n        mkdir(bundler.dests.containerDir); //TODO async\n        mkdir(bundler.dests.dir);\n        if (!(options.packedAssets && options.packedAssets.keepOldFiles)) {\n          deleteOldFiles(bundler.dests.dir);\n        }\n        done();\n\n        //TODO add the tasks to an async queue that can be asserted on in tests\n      });\n\n      ss.defaultTask(bundler.client.name+':pack-css', function(done) {\n        ss.bundler.packAssetSet('css', bundler.client, bundler.toMinifiedCSS,done);\n      });\n\n      ss.defaultTask(bundler.client.name+':pack-js', function(done) {\n        //TODO wait for ss.loaded promise to have socketstream-transport defined\n        ss.bundler.packAssetSet('js', bundler.client, bundler.toMinifiedJS,done);\n      });\n\n      ss.defaultTask(bundler.client.name+':pack-html', function(done) {\n        view(ss, bundler.client, options, function(html) {\n          fs.writeFileSync(bundler.dests.paths.html, html);\n          ss.log.info('✓'.green, 'Created and cached HTML file ' + bundler.dests.relPaths.html);\n\n          //TODO perhaps put this in pack-completion target\n          log.info(' ','Bundler',bundler.client.name,'packed.');\n          bundler.packNeeded = false;\n          done();\n        });\n      });\n      ss.defaultTask(name+':pack', [\n        name+':pack-prepare',\n        name+':pack-css',\n        name+':pack-js',\n        name+':pack-html']);\n    });\n\n    ss.defaultTask('pack-all', this._packTasks(true));\n    ss.defaultTask('pack-if-needed', this._packTasks());\n    ss.defaultTask('pack-prepare', function() {\n      log.info('i'.green, 'Attempting to find pre-packed assets... (force repack with SS_PACK=1)'.grey);\n    });\n  };\n};\n\nfunction mkdir(dir) {\n  if (!fs.existsSync(dir)) {\n    return fs.mkdirSync(dir);\n  }\n}\n\nfunction deleteOldFiles(clientDir) {\n  var filesDeleted = fs.readdirSync(clientDir).map(function(fileName) {\n    return fs.unlinkSync(path.join(clientDir, fileName));\n  });\n  return filesDeleted.length > 1 && log.info('✓'.green, '' + filesDeleted.length + ' previous packaged files deleted');\n}\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/request/index.js":"// Request Responders\n// ------------------\n// Processes incoming requests regardless of transport (e.g. websocket, HTTP, method call from console)\n// Each responder can expose a number of interfaces - e.g. Websocket, Console, and will only respond to incoming\n// messages of it's type (e.g. 'rpc', 'events', etc)\n// Responders can optionally choose to use the middleware stack provided\n// The 'events' and 'rpc' responders are loaded by default, though even this can be overruled by calling clear()\n'use strict';\n\nmodule.exports = function(ss) {\n  var middleware = require('./middleware')(ss),\n      responderCount = 0,\n      responders = {},\n      useDefaults = true;\n\n  return {\n    clear: function() {\n      //jshint -W093\n      return (useDefaults = false);\n    },\n    add: function(nameOrModule, config) {\n      config = config || null;\n      var mod = ss.require(nameOrModule, 'request/responders',function(err) {\n            throw new Error('Unable to find the \\''+err.id+'\\' Request Responder internally');\n          });\n\n      try {\n        var id = nameOrModule === 'events' && '0' || ++responderCount;\n        //jshint -W093\n        return (responders[id] = mod(id, config, ss));\n      } catch (e) {\n        var responderName = responders[id] && responders[id].name || '',\n            err = new Error('Unable to initialize Request Responder \\'' + responderName + '\\'');\n        err.stack = e.stack;\n        throw e;\n      }\n    },\n    load: function() {\n      var middlewareStack = middleware.load();\n      if (useDefaults) {\n        this.add('events');\n        this.add('rpc');\n      }\n      var output = {};\n      for (var id in responders) {\n        var responder = responders[id];\n        output[id] = {\n          name: responder.name,\n          interfaces: responder.interfaces(middlewareStack)\n        };\n      }\n      return output;\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/request/middleware/index.js":"// Request Middleware\n// ------------------\n// Allows incoming requests to be pre-processed, transformed, or sent elsewhere\n'use strict';\n\nvar pathlib = require('path'),\n    fs = require('fs'),\n    apiTree = require('apitree');\n\nmodule.exports = function(ss) {\n  // Load internal middleware\n  var internal = require('./internal')(ss);\n  return {\n\n    // Return API\n    load: function() {\n\n      var customDir = pathlib.join(ss.root, 'server/middleware');\n\n      // Load custom middleware\n      var stack = fs.existsSync(customDir) && apiTree.createApiTree(customDir) || {};\n\n      // Append internal/default middleware\n      for (var k in internal) {\n        stack[k] = internal[k];\n      }\n      return stack;\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/request/middleware/internal.js":"// Internal Request Middleware\n// ---------------------------\n// Internal middleware occupies the top-level namespace, i.e. does not contain any dots\n'use strict';\n\nvar colors = require('colors/safe');\n\nmodule.exports = function(ss) {\n  return {\n    debug: function(color) {\n      return function(request, response, next) {\n        ss.log.info(colors[color || 'yellow']('Debug incoming message >>\\n'), request);\n        return next();\n      };\n    },\n    session: function(options) {\n      if (!options) {\n        options = {};\n      }\n      return function(request, response, next) {\n        if (request.sessionId) {\n          return ss.session.find(request.sessionId, request.socketId, function(thisSession) {\n            request.session = thisSession;\n            if (options.debug) {\n              ss.log.info(colors.yellow('Debug session >>\\n'), thisSession);\n            }\n            if (thisSession) {\n              return next();\n            } else {\n              return ss.log.error(('! Error: Session ID ' + request.sessionId +\n                ' not found. Use Redis to persist sessions between server restarts. Terminating incoming request').red);\n            }\n          });\n        } else {\n          throw new Error('Cannot load session. Request does not contain a sessionId');\n        }\n      };\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/websocket/index.js":"// Websocket Module\n// ----------------\n// Handles everything to do with the websocket transport and message responders\n'use strict';\n\nvar debug = require('debug')('socketstream'),\n    EventEmitter2 = require('eventemitter2').EventEmitter2,\n    emitter = new EventEmitter2({\n      wildcard: true\n    });\n\nmodule.exports = function(ss) {\n\n  // Return API\n  var transport = require('./transport')(ss, emitter);\n\n  return {\n    /**\n     * @ngdoc service\n     * @name http.index:index#listen\n     * @methodOf http.index:index\n     * @function\n     * @description\n     * Start the server listening to the port (same as Server.listen)\n     */\n    listen: function(port,cb) {\n      ss.load();\n      ss.log.info('Starting SocketStream %s in %s mode...'.green, ss.version, ss.env);\n      if (Number(ss.version.split('.')[1]) % 2) {\n        ss.log.info('This is an unstable version, some features will not be reliable'.yellow);\n      }\n      return transport.http.listen(port,function() {\n        debug('started streaming server.');\n        if (cb) {\n          return cb();\n        }\n      });\n    },\n\n    transport: transport,\n    unload: function() {},\n    load: function(responders, eventTransport) {\n      var thisTransport = transport.load();\n\n      // Dispatch incoming events to websocket clients\n      require('./event_dispatcher')(eventTransport, thisTransport, emitter);\n\n      // Listen to incoming requests and invoke server.request\n      for (var id in responders) {\n        var responder = responders[id];\n        emitter.on(id, responder.interfaces.websocket);\n      }\n\n      // Return active WS transport\n      return thisTransport;\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/websocket/transport.js":"// Websocket Transport\n// -------------------\n// Define the transport to carry all realtime requests\n// Uses 'engineio' by default. See README to see how to configure it\n'use strict';\n\nmodule.exports = function(ss, emitter) {\n  var mid,\n      active,\n      config = {};\n\n  return {\n    get http() {\n      return active? active.http: null;\n    },\n    get ws() {\n      return active? active.ws: null;\n    },\n    use: function(nameOrModule, cfg) {\n      mid = nameOrModule;\n      config = cfg || config;\n\n      // log warning\n      // if (ss.require.resolve(nameOrModule, 'websocket/transports') == null) {\n      //   throw new Error('Unable to find the \\'' + nameOrModule + '\\' websocket transport internally');\n      // }\n    },\n    load: function() {\n      //TODO error handle missing require from within the sockjs/engineio module\n      var transport = ss.require(mid, 'websocket/transports', 'engineio');\n      if (typeof transport !== 'function') {\n        ss.log.error('Transport for \"'+mid+'\" must be a function(ss, emitter, config) default:', transport);\n      } else {\n        return (active = transport(ss, emitter, config));\n      }\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/express.js":"// Entry point for app.js\n'use strict';\n\nvar ss = require('./lib/socketstream.js'),\n    express = ss.api.require('express');\n\nmodule.exports = function() {\n  var app = ss.http.middleware = express();\n\n  app.listen = function() {\n    ss.ws.listen.apply(ss.ws, arguments);\n  };\n  /* TODO\n  app.socketstream = function( fn(req,stream) )\n\n  app.stream = ss.http.stream;\n  */\n  app.stream = ss.http.stream;\n\n  if (ss.env === 'development') {\n    app.set('views', ss.client.dirs.views);\n    // Showing stack errors\n    app.set('showStackError', true);\n    // Disable views cache\n    app.set('view cache', false);\n\n    // Environment dependent middleware\n    // throws cannot find stack\n    // ss.api.require('express-debug')(app, {/* settings */});\n  }\n\n  return app;\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/Gruntfile.js":"/*global module:false*/\n\nmodule.exports = function(grunt) {\n    'use strict';\n\n    var sh = require('shelljs');\n\n    grunt.loadNpmTasks('grunt-conventional-changelog');\n    grunt.loadNpmTasks('grunt-contrib-connect');\n    grunt.loadNpmTasks('grunt-contrib-clean');\n    grunt.loadNpmTasks('grunt-contrib-watch');\n    grunt.loadNpmTasks('grunt-concurrent');\n    grunt.loadNpmTasks('grunt-ngdocs');\n\n    grunt.initConfig({\n        docsSever: {\n            port: 9001,\n        },\n        clean: {\n            docs: {\n                src: ['docs']\n            }\n        },\n        ngdocs: {\n            options: {\n                title: 'SocketStream',\n                scripts: [\n                    'angular.js',\n                ],\n                styles: [\n                    'src/docs/site/css/main.css'\n                ],\n                // navTemplate: 'src/docs/site/header.html',\n                startPage: 'tutorials',\n                titleLink: '#/tutorials',\n                discussions: {\n                    shortName: 'socketstream',\n                    url: 'http://romanminkin.github.io/socketstream/docs/',\n                    dev: true\n                },\n                html5Mode: false,\n                bestMatch: true\n            },\n            tutorials: {\n                src: ['src/docs/tutorials/**/*.ngdoc'],\n                title: 'Tutorials'\n            },\n            api: {\n                src: ['lib/**/*.js'],\n                title: 'API Documentation'\n            },\n            demos: {\n                src: ['src/docs/demos/**/*.ngdoc'],\n                title: 'Demos'\n            },\n        },\n        concurrent: {\n            options: {\n                logConcurrentOutput: true\n            },\n            docsSite: ['delta:docs', 'connect:docsSite']\n        },\n        delta: {\n            docs: {\n                options: {\n                    interrupt: true,\n                    atBegin: true\n                },\n                files: [\n                    'lib/**',\n                    'src/**'\n                ],\n                tasks: ['clean', 'ngdocs']\n            }\n        },\n        connect: {\n            options: {\n            },\n            docsSite: {\n                options: {\n                    port     : '<%= docsSever.port %>',\n                    keepalive: true,\n                    base     : 'docs',\n                }\n            }\n        },\n        shell: {\n            //We use %version% and evluate it at run-time, because <%= pkg.version %>\n            //is only evaluated once\n            'release-prepare': [\n                'grunt is-gh-pages-branch-exist',\n                'grunt build:docs',\n                'grunt is-clean:master',\n                'grunt version',    //remove \"-SNAPSHOT\" from the project's version in package.json\n                'grunt changelog'\n            ],\n            'release-complete': [\n                'git commit CHANGELOG.md package.json -n -m \"chore(release): v%version%\"',\n                'git tag %version%'\n            ],\n            'release-start': [\n                'grunt version:patch:\"SNAPSHOT\"',\n                'git commit package.json -n -m \"chore(release): Starting v%version%\"'\n            ],\n            'release-push': [\n                'git push origin master',\n                'git push origin gh-pages',\n                'git push --tags',\n            ],\n            'update-gh-pages': [\n                'git checkout gh-pages',\n                'git merge master',\n                'git checkout master'\n            ]\n        },\n        changelog: {\n            options: {\n                dest: 'CHANGELOG.md',\n                templateFile: 'src/docs/changelog.tpl.md',\n                github: 'socketstream/socketstream'\n            }\n        },\n    });\n\n    // Rename our watch task to 'delta', then make actual 'watch'\n    grunt.renameTask('watch', 'delta');\n\n    /**\n     * Sets version in 'package.json' in http://semver.org friendly mode\n     *\n     * @param {String} type   Could be 'major', 'minor' or 'patch'\n     * @param {String} suffix Suffic string, example: 'alpha', 'pre-alpha', 'beta'\n     */\n    function setVersion(type, suffix) {\n        var file = 'package.json',\n            VERSION_REGEX = /([\\'|\\\"]version[\\'|\\\"][ ]*:[ ]*[\\'|\\\"])([\\d|.]*)(-\\w+)*([\\'|\\\"])/,\n            contents = grunt.file.read(file),\n            version;\n        contents = contents.replace(VERSION_REGEX, function(match, left, center) {\n            version = center;\n            if (type) {\n                version = require('semver').inc(version, type);\n            }\n            //semver.inc strips our suffix if it existed\n            if (suffix) {\n                version += '-' + suffix;\n            }\n            return left + version + '\"';\n        });\n        grunt.log.ok('Version set to ' + version.cyan);\n        grunt.file.write(file, contents);\n        return version;\n    }\n\n    /**\n     * Task for setting project version according to http://semver.org\n     * @usage\n     *     grunt version:type:suffix\n     *\n     *     // suppose current version in package.json is \"0.3.10\"\n     *\n     *     grunt version:patch // will set version to \"0.3.11\"\n     *     grunt version:patch // one more call will increas version to \"0.3.12\"\n     *\n     *     grunt version:minor:\"alpha\" // this one will set up version to \"0.4.0-alpha\"\n     *\n     *     grunt version\" // this clean up current vesion to valid according to http://semver.org,\n     *                    // so \"0.3.10-SNAPSHOT\" will become \"0.3.10\"\n     */\n    grunt.registerTask('version', 'Set version. If no arguments, it just takes off suffix', function() {\n        setVersion(this.args[0], this.args[1]);\n    });\n\n    grunt.registerTask('enforce', 'Install commit message enforce script if it doesn\\'t exist', function() {\n        if (!grunt.file.exists('.git/hooks/commit-msg')) {\n            grunt.file.copy('misc/validate-commit-msg.js', '.git/hooks/commit-msg');\n            require('fs').chmodSync('.git/hooks/commit-msg', '0755');\n        }\n    });\n\n    /**\n     * Check is master(default) or specified branch is clean for commit\n     *\n     *  grunt:is-clean // checks 'master' branch\n     *  grunt:is-clean:test // checks 'test' branch\n     *\n     * @param {String} Branch name to check\n     */\n    grunt.registerTask('is-clean', 'Install commit message enforce script if it doesn\\'t exist', function() {\n        var result,\n            branch = this.args[0] ? this.args[0] : 'master';\n\n        result = sh.exec('git symbolic-ref HEAD', {silent: true});\n        if (result.output.trim() !== 'refs/heads/' + branch) {\n            throw new Error('Not on master branch, aborting! Current branch is \\'' + result.output.trim() + '\\'');\n        }\n\n        result = sh.exec('git status --porcelain', {silent: true});\n        if (result.output.trim() !== '') {\n            grunt.log.error(result.output.trim());\n            throw new Error('Working copy is dirty, aborting!');\n        }\n    });\n\n    grunt.registerTask('is-gh-pages-branch-exist', 'Check if gh-pages branch exists, if not create it', function() {\n        var result,\n            branch = this.args[0];\n\n        result = sh.exec('git branch | grep gh-pages', {silent: true});\n        if (result.output.trim() ===  '') {\n            sh.exec('git branch gh-pages origin/gh-pages' + branch, {silent: true})\n        }\n    });\n\n    grunt.registerMultiTask('shell', 'run shell commands', function() {\n        var self = this;\n\n        self.data.forEach(function(cmd) {\n            cmd = cmd.replace('%version%', grunt.file.readJSON('package.json').version);\n            grunt.log.ok(cmd);\n\n            var result = sh.exec(cmd, { silent: true });\n\n            if (result.code !== 0) {\n                grunt.fatal(result.output);\n            }\n        });\n    });\n\n    grunt.registerTask('default', 'Default task which runs all the required subtasks', []);\n    grunt.registerTask('build:docs', 'Build documentation', ['clean:docs', 'ngdocs']);\n    grunt.registerTask('watch:docs', 'Watching for changes and re-building docs', ['concurrent:docsSite']);\n    grunt.registerTask('update:docs', 'Update gh-page branch by merging from master', ['shell:update-gh-pages']);\n\n    grunt.registerTask('release:start', 'Increase patch version by 1, add suffix \"SNAPSHOT\" as \"major.minor.(patch+1)-SNAPSHOT\" and commit package.json', ['shell:release-start']);\n    grunt.registerTask('release:prepare', 'Run all the tests, generates CHANGELOG.md since laste release and and clean up version to just \"major.minor.patch\"', ['shell:release-prepare']);\n    grunt.registerTask('release:complete', 'Complete release by commiting CHANGELOG.md and package.json and adding version tag', ['shell:release-complete', 'shell:update-gh-pages']);\n    grunt.registerTask('release:push', 'Push to origin tags, master and gh-pages branches', ['shell:release-push']);\n}\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/gulp.js":"// Entry point for gulpfile.js\n\n// Load SocketStream core\nvar ss = module.exports = require('./lib/socketstream.js'),\n    gulp = ss.api.require('gulp');\n\n// gulp is used as the Orchestrator\nss.tasks.use(gulp);\n\n// Your app.js should be required from the gulpfile.js\n// .start() will normally be called from app.js, and will not run tasks.\nss.start = function() {};\n\n// default tasks are defined\nss.tasks.defaults();\n\n// don't load API yet as the app.js still needs to be loaded\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/misc/validate-commit-msg.js":"#!/usr/bin/env node\n\n'use strict';\n\n/**\n * Git COMMIT-MSG hook for validating commit message\n * See https://docs.google.com/document/d/1rk04jEuGfk9kYzfqCuOlPTSJw3hEDZJTBN5E5f1SALo/edit\n *\n * Installation:\n * >> cd <angular-repo>\n * >> ln -s validate-commit-msg.js .git/hooks/commit-msg\n */\n\nvar fs, util, MAX_LENGTH, PATTERN, IGNORED, TYPES, match, type;\n\nfs = require('fs');\nutil = require('util');\n\n\nMAX_LENGTH = 70;\nPATTERN = /^(?:fixup!\\s*)?(\\w*)(\\((\\w+)\\))?\\: (.*)$/;\nIGNORED = /^WIP\\:/;\nTYPES = {\n  chore: true,\n  demo: true,\n  docs: true,\n  feat: true,\n  fix: true,\n  refactor: true,\n  revert: true,\n  style: true,\n  test: true\n};\n\n\nvar error = function() {\n  // gitx does not display it\n  // http://gitx.lighthouseapp.com/projects/17830/tickets/294-feature-display-hook-error-message-when-hook-fails\n  // https://groups.google.com/group/gitx/browse_thread/thread/a03bcab60844b812\n  console.error('INVALID COMMIT MSG: ' + util.format.apply(null, arguments));\n};\n\n\nvar validateMessage = function(message) {\n  var isValid = true;\n\n  if (IGNORED.test(message)) {\n    console.log('Commit message validation ignored.');\n    return true;\n  }\n\n  if (message.length > MAX_LENGTH) {\n    error('is longer than %d characters !', MAX_LENGTH);\n    isValid = false;\n  }\n\n  match = PATTERN.exec(message);\n\n  if (!match) {\n    error('does not match \"<type>(<scope>): <subject>\" ! was: \"' + message + '\"\\nNote: <scope> must be only letters.');\n    return false;\n  }\n\n  type    = match[1];\n  // scope   = match[3];\n  // subject = match[4];\n\n  if (!TYPES.hasOwnProperty(type)) {\n    error('\"%s\" is not allowed type !', type);\n    return false;\n  }\n\n  // Some more ideas, do want anything like this ?\n  // - allow only specific scopes (eg. fix(docs) should not be allowed ?\n  // - auto correct the type to lower case ?\n  // - auto correct first letter of the subject to lower case ?\n  // - auto add empty line after subject ?\n  // - auto remove empty () ?\n  // - auto correct typos in type ?\n  // - store incorrect messages, so that we can learn\n\n  return isValid;\n};\n\n\nvar firstLineFromBuffer = function(buffer) {\n  return buffer.toString().split('\\n').shift();\n};\n\n\n\n// publish for testing\nexports.validateMessage = validateMessage;\n\n// hacky start if not run by jasmine :-D\nif (process.argv.join('').indexOf('jasmine-node') === -1) {\n  var commitMsgFile = process.argv[2];\n  var incorrectLogFile = commitMsgFile.replace('COMMIT_EDITMSG', 'logs/incorrect-commit-msgs');\n\n  fs.readFile(commitMsgFile, function(err, buffer) {\n    var msg = firstLineFromBuffer(buffer);\n\n    if (!validateMessage(msg)) {\n      fs.appendFile(incorrectLogFile, msg + '\\n', function() {\n        process.exit(1);\n      });\n    } else {\n      process.exit(0);\n    }\n  });\n}","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/cli/generate.js":"/**\n * New App Generator\n * -----------------\n * Generates skeleton files needed to create a new SocketStream application\n */\n\n'use strict';\n\nrequire('colors');\n\nvar fs       = require('fs'),\n    path     = require('path'),\n    log      = console.log,\n    dir_mode = '0755',\n\n    // Private\n    success = function(name, alternative) {\n      return log(' ✓'.green, name, (alternative || '').grey);\n    },\n\n    // TODO - investigate whether this would be better\n    // using the async version of fs.mkdir - PJENSEN\n    makeRootDirectory = function (name) {\n      try {\n        fs.mkdirSync(name, dir_mode); // Create the root directory\n        return true;\n      } catch (e) {\n        if (e.code === 'EEXIST') {\n          log('Sorry the \\'' + name + '\\' directory already exists. Please choose another name for your app.');\n          return false;\n        } else {\n          throw e;\n        }\n      }\n  };\n\nexports.generate = function(program) {\n\n  var appjs,\n      codeExtension = program.coffee && 'coffee' || 'js',\n      selectedFormatters = [],\n      name               = program.args[1],\n      source             = path.join(__dirname, '../../new_project'),\n      viewExtension      = program.jade && 'jade' || 'html',\n      styleExtension     = '',\n      mods               = [],\n      packagejs          = '',\n      clientFiles        = {\n        css: [],\n        code: []\n      },\n\n      /**\n       * [mkdir description]\n       * @param  {String}   dir Directory path to create\n       * @return {Boolean}      True if directory successfully created\n       */\n      mkdir = function(dir) {\n        return fs.mkdirSync(path.join(name, dir), dir_mode);\n      },\n\n      /**\n       * Copy files/directories\n       * @param  {[String} src  Copy From directory\n       * @param  {[String} dest Copy To directory\n       * @return {Object}       Stream object\n       */\n      cp = function(src, dest) {\n        var destination = path.join(name, dest || src),\n            read        = fs.createReadStream(path.join(source, src)),\n            write       = fs.createWriteStream(destination);\n\n        return read.pipe(write);\n      },\n\n      /**\n       * Writes content to the file\n       * @param  {String} fileName The filepath to write to\n       * @param  {[type]} content  Content string\n       * @return {Boolean}\n       */\n      write = function(fileName, content) {\n        return fs.writeFileSync(path.join(name, fileName), content, 'utf8');\n      };\n\n  /* Check for application name existing */\n  if (name === void 0) {\n    return log('Please provide a name for your application: $> socketstream new <MyAppName>');\n  }\n\n  /* Select stylesheet language */\n  if (program.less) {\n    styleExtension = 'less';\n  }\n  else if (program.stylus) {\n    styleExtension = 'styl';\n  }\n  else {\n    styleExtension = 'css';\n  }\n\n  /* Select formatters for file extensions */\n  if (makeRootDirectory(name)) {\n    ['coffee', 'jade', 'less', 'stylus'].forEach(function(formatter) {\n      if (program[formatter]) {\n        return selectedFormatters.push(formatter);\n      }\n    });\n\n    /* Create essential directories */\n    mkdir('/client');\n    mkdir('/client/code');\n    mkdir('/client/code/app');\n    mkdir('/client/code/libs');\n    mkdir('/client/views');\n    mkdir('/client/css');\n    mkdir('/client/css/libs');\n    mkdir('/client/templates');\n    mkdir('/client/static');\n    mkdir('/client/static/images');\n    mkdir('/server');\n    mkdir('/server/rpc');\n    mkdir('/server/middleware');\n\n    /* Copy essential files */\n    cp('/scm_ignore_file', '/.gitignore');\n    cp('/node_monitor_ignore_file', '/.nodemonignore');\n    cp('/README.md');\n    cp('/client/static/favicon.ico');\n    cp('/client/code/libs/jquery.min.js');\n    cp('/client/code/app/entry.' + codeExtension);\n    clientFiles.code.push('../node_modules/es6-shim/es6-shim.js');\n    clientFiles.code.push('libs/jquery.min.js');\n    clientFiles.code.push('app');\n\n    /* Install chat demo files */\n    if (program.minimal) {\n      cp('/client/views/app.minimal.' + viewExtension, '/client/views/app.' + viewExtension);\n      cp('/client/code/app/app.minimal.' + codeExtension, '/client/code/app/app.' + codeExtension);\n      cp('/client/css/app.minimal.' + styleExtension, '/client/css/app.' + styleExtension);\n      cp('/server/rpc/.gitkeep');\n      cp('/server/middleware/.gitkeep');\n      cp('/client/templates/.gitkeep');\n      clientFiles.css.push('app.' + styleExtension);\n    } else {\n      cp('/client/static/images/logo.png');\n      cp('/client/code/app/app.demo.' + codeExtension, '/client/code/app/app.' + codeExtension);\n      cp('/server/middleware/example.' + codeExtension);\n      cp('/server/rpc/demo.' + codeExtension);\n      cp('/client/css/app.demo.' + styleExtension, '/client/css/app.' + styleExtension);\n      mkdir('/client/templates/chat');\n      cp('/client/templates/chat/message.' + viewExtension);\n      cp('/client/views/app.demo.' + viewExtension, '/client/views/app.' + viewExtension);\n      clientFiles.css.push('../node_modules/normalize.css/normalize.css');\n      clientFiles.css.push('app.' + styleExtension);\n    }\n\n    /* Generate app.js */\n    appjs = '// My SocketStream 0.4 app\\n\\nvar ss = require(\\'socketstream\\');\\n\\n'+\n            '// Define a single-page client called \\'main\\'\\nss.client.define(\\'main\\', {\\n  view: \\'app.' + viewExtension + '\\',\\n  css:  [\\'' + (clientFiles.css.join('\\', \\'')) + '\\'],\\n  code: [\\'' + (clientFiles.code.join('\\', \\'')) + '\\'],\\n  tmpl: \\'chat\\'\\n});\\n\\n// Serve this client on the root URL\\nss.http.route(\\'/\\', function(req, res){\\n  res.serveClient(\\'main\\');\\n});\\n';\n\n    /* List any selected formatters */\n    if (selectedFormatters.length > 0) {\n      appjs += '\\n// Code Formatters\\n';\n    }\n    selectedFormatters.forEach(function (name) {\n      return appjs += 'ss.client.formatters.add(require(\\'ss-' + name + '\\'));\\n';\n    });\n    appjs += '\\n// Use server-side compiled Hogan (Mustache) templates. Others engines available\\n'+\n             'ss.client.templateEngine.use(require(\\'ss-hogan\\'));\\n\\n// Minimize and pack assets if you type: SS_ENV=production node app.js\\n'+\n             'if (ss.env === \\'production\\') ss.client.packAssets();\\n';\n    if (program.repl) {\n      appjs += '\\n// Start Console Server (REPL)\\n// To install client: sudo npm install -g ss-console\\n'+\n               '// To connect: ss-console <optional_host_or_port>\\nvar consoleServer = require(\\'ss-console\\')(ss);\\nconsoleServer.listen(5000);\\n';\n    }\n    appjs += '\\n// Start SocketStream\\nss.start();';\n    write('/app.js', appjs);\n\n    /* Generate package.json */\n    packagejs = '{\\n  \"name\": \"' + name + '\",\\n  \"description\": \"An awesome real time application\",\\n  \"version\": \"0.0.1\",\\n'+\n                '  \"author\": \"Me <me@mydomain.com>\",\\n  \"private\": true,\\n  \"engines\": { \"node\": \">= 0.10.0\" },\\n  \"dependencies\": {';\n    packagejs += '\\n    \"normalize.css\": \"3.0.x\",';\n    packagejs += '\\n    \"es6-shim\": \"0.33.x\",';\n    packagejs += '\\n    \"socketstream\": \"0.5.x\",';\n    packagejs += '\\n    \"socketstream-cookie-session\": \"0.5.x\",';\n    packagejs += '\\n    \"chokidar\": \"1.4.x\",';\n    packagejs += '\\n    \"connect\": \"3.4.x\",';\n    packagejs += '\\n    \"socketstream-cookie-session\": \"0.5.x\",';\n    packagejs += '\\n    \"engine.io\": \"1.5.2\",';\n    packagejs += '\\n    \"engine.io-client\": \"1.5.2\"'\n    mods = selectedFormatters.concat(['hogan']);\n    if (program.repl) {\n      mods.push('console');\n    }\n    mods.forEach(function (name) {\n      return packagejs += ',\\n    \"ss-' + name + '\": \"0.1.x\"';\n    });\n\n    packagejs += '\\n  },\\n  \"scripts\":{\\n    \"start\":\"node app.js\"\\n  }\\n}';\n    write('/package.json', packagejs);\n\n    /* Show finish text */\n    log(('Success! Created app \\'' + name + '\\' with:').yellow);\n\n    if (program.minimal) {\n      success('Minimal install (no demo)');\n    } else {\n      success('Basic chat demo', '(-m for minimal install)');\n    }\n    if (program.coffee) {\n      success('CoffeeScript example code');\n    } else {\n      success('Javascript example code', '(-c if you prefer CoffeeScript)');\n    }\n    if (program.jade) {\n      success('Jade for views');\n    } else {\n      success('Plain HTML for views', '(-j if you prefer Jade)');\n    }\n    if (program.less) {\n      success('Less for CSS');\n    } else if (program.stylus) {\n      success('Stylus for CSS')\n    } else {\n      success('Plain CSS', '(-s if you prefer Stylus, -l for Less)');\n    }\n\n    /* Add the REPL if selected */\n    if (program.repl) {\n      success('Console Server / REPL');\n    }\n\n    log('Next, run the following commands:'.yellow);\n    log('   cd ' + name);\n    log('   [sudo] npm install');\n    log('To start your app:'.yellow);\n    log('   node app.js');\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/utils/misc.js":"/*jslint bitwise: true*/\n\n'use strict';\n\n/**\n * @ngdoc service\n * @name utils.misc:misc\n * @function\n *\n * @description\n * Module contains misc methods\n */\n\n\n/**\n * @ngdoc service\n * @name utils.misc#randomString\n * @methodOf utils.misc:misc\n * @function\n *\n * @description\n * Adapted from http://www.broofa.com/Tools/Math.uuid.js\n *\n * @param {String}  len   Length of the expected string\n * @return {String}       uuid string\n */\nexports.randomString = function (len) {\n  var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''),\n      uuid  = [],\n      radix = chars.length,\n      i;\n\n  for (i = 0; i < len; i++) {\n    uuid[i] = chars[0 | Math.random()*radix];\n  }\n  return uuid.join('');\n};\n\n/**\n * @ngdoc service\n * @name utils.misc#parseWsMessage\n * @methodOf utils.misc:misc\n * @function\n *\n * @description\n * Parse incoming websocket messages into message type and contents\n *\n * @param  {String} msg Message to parse\n * @return {Array}      Array, where [0] is message type, [1] is message's body\n */\nexports.parseWsMessage = function (msg) {\n  var i;\n  if ((i = msg.indexOf('|')) > 0) {\n    return [msg.substr(0, i), msg.substr(i+1)];\n  } else {\n    throw new Error('Invalid message');\n  }\n};\n\n/**\n * @ngdoc service\n * @name utils.misc#extend\n * @methodOf utils.misc:misc\n * @function\n *\n * @description\n * Taken from underscore.js\n *\n * @param  {Object}     obj         Object to extend\n * @param  {<Objects>}  <objects>  to extend with\n * @return {Object}                 Extended object\n */\nexports.extend = function (obj) {\n  var source,\n      prop,\n      i;\n\n  for (i = 1; i < arguments.length; i++) {\n    source = arguments[i];\n    for (prop in source) {\n      if (source.hasOwnProperty(prop)) {\n        obj[prop] = source[prop];\n      }\n    }\n  }\n  return obj;\n};\n\n/**\n * @ngdoc service\n * @name utils.misc#defaults\n * @methodOf utils.misc:misc\n * @function\n *\n * @description\n * Useful for declaring default parameter\n *\n * @param  {Object} args      Arguments\n * @param  {Object} defaults  Default arguments\n * @return {Object}           Extended object\n */\nexports.defaults = function (args, defaults) {\n  return exports.extend({}, defaults, args);\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/websocket/event_dispatcher.js":"// Websocket Event Dispatcher\n// --------------------------\n// Delivers events to individual (or groups of) websocket IDs \n'use strict';\n\nvar subscriptions = require('./subscriptions');\n\nmodule.exports = function(eventTransport, wsTransport, emitter) {\n  return eventTransport.listen(function(obj) {\n    var send = wsTransport.event();\n\n    // Emit message to the event responder (always Responder ID 0)    \n    return emitter.emit('0', obj, {}, andThen());\n\n    function andThen() {\n      switch (obj.t) {\n        case 'all':\n          return function(msg) {\n            return send.all(msg);\n          };\n        case 'socketId':\n          return function(msg) {\n            return send.socketId(obj.socketId, msg);\n          };\n        case 'channel':\n          return function(msg) {\n            return sendToMultiple(send, msg, obj.channels, 'channel');\n          };\n        case 'user':\n          return function(msg) {\n            return sendToMultiple(send, msg, obj.users, 'user');\n          };\n      }\n    }\n  });\n};\n\n\n// Private\n\n// Attempt to send the event to the socket. If socket no longer exists, remove it from set\nfunction sendToMultiple(send, msg, destinations, type) {\n  destinations = destinations instanceof Array && destinations || [destinations];\n  destinations.forEach(function(destination) {\n    var set, socketIds;\n    set = subscriptions[type];\n    if ((socketIds = set.members(destination))) {\n      return socketIds.slice(0).forEach(function(socketId) {\n        if (!send.socketId(socketId, msg, destination)) {\n          return set.removeFromAll(socketId);\n        }\n      });\n    }\n  });\n  return true;\n}\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/client/bundler/browserify.client.js":"// Module loading code from Browserify: https://github.com/substack/node-browserify\n\nwindow.require = function (file, cwd) {\n    var resolved = require.resolve(file, cwd || '/');\n    var mod = require.modules[resolved] || require.initModule(resolved);\n    if (!mod) throw new Error(\n        'Failed to resolve module ' + file + ', tried ' + resolved\n    );\n    return mod._cached ? mod._cached : mod();\n};\n\nrequire.paths = [];\nrequire.modules = {};\n\nrequire._core = {\n    'events': true, // FUTURE_WORK, support events?\n    'path': true,\n    'vm': true // FUTURE_WORK, support vm ?\n};\n\nrequire.resolve = function (x, cwd) {\n  if (!cwd) { cwd = '/'; }\n\n  if (require._core[x]) {return x;}\n  var path = require.modules.path();\n\n  // strip extension\n  var ext = path.extname(x);\n  if (ext) {\n    x = x.substring(0, x.length - ext.length);\n  }\n\n  // paths are ../ or ./ or /\n  x = x.charAt(0) === '/' ? path.resolve(cwd, x.substring(1)) : x;\n  x = x.match(/^(?:\\.\\.?\\/)/) ? path.resolve(cwd,x) : x;\n\n  var resolved = firstMatch(\n    x, // as a file\n    path.join(x,'index') // as a directory\n  );\n  if (resolved) {return resolved;}\n\n  throw new Error(\"Cannot find module '\" + x + \"' within '\"+cwd+\"'\");\n\n  function firstMatch() {\n    for(var i= 0,a; (a = arguments[i]); ++i) {\n      if (require.modules[a]) { return a; }\n    }\n  }\n};\n\nrequire.alias = function (from, to) {\n    var path = require.modules.path();\n    var res = null;\n    try {\n        res = require.resolve(from + '/package.json', '/');\n    }\n    catch (err) {\n        res = require.resolve(from, '/');\n    }\n    var basedir = path.dirname(res);\n\n    var keys = (Object.keys || function (obj) {\n        var res = [];\n        for (var key in obj) res.push(key)\n        return res;\n    })(require.modules);\n\n    for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        if (key.slice(0, basedir.length + 1) === basedir + '/') {\n            var f = key.slice(basedir.length);\n            require.modules[to + f] = require.modules[basedir + f];\n        }\n        else if (key === basedir) {\n            require.modules[to] = require.modules[basedir];\n        }\n    }\n};\n\nrequire.define = function (filename, fn) {\n    //if (filename.substring(0,3) === '/./') { filename = filename.substring(2); }\n    var dirname = require._core[filename]\n        ? ''\n        : require.modules.path().dirname(filename)\n    ;\n\n    var require_ = function (file) {\n        return require(file, dirname)\n    };\n    require_.resolve = function (name) {\n        return require.resolve(name, dirname);\n    };\n    require_.modules = require.modules;\n    require_.define = require.define;\n    var module_ = { exports : {} };\n\n    require.modules[filename] = function () {\n        require.modules[filename]._cached = module_.exports;\n        fn.call(\n            module_.exports,\n            require_,\n            module_,\n            module_.exports,\n            dirname,\n            filename\n        );\n        require.modules[filename]._cached = module_.exports;\n        return module_.exports;\n    };\n};\n\nif (typeof process === 'undefined') process = {};\n\nif (!process.nextTick) process.nextTick = (function () {\n    var queue = [];\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener\n    ;\n\n    if (canPost) {\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'browserify-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n    }\n\n    return function (fn) {\n        if (canPost) {\n            queue.push(fn);\n            window.postMessage('browserify-tick', '*');\n        }\n        else setTimeout(fn, 0);\n    };\n})();\n\nif (!process.title) process.title = 'browser';\n\nif (!process.binding) process.binding = function (name) {\n    if (name === 'evals') return require('vm')\n    else throw new Error('No such module')\n};\n\nif (!process.cwd) process.cwd = function () { return '.' };\n\nrequire.define(\"path\", function (require, module, exports) {\n  // deprecated. Array.filter will be used in the future ES5 shim required for older browsers.\n  function filter (xs, fn) {\n      var res = [];\n      for (var i = 0; i < xs.length; i++) {\n          if (fn(xs[i], i, xs)) res.push(xs[i]);\n      }\n      return res;\n  }\n\n  // resolves . and .. elements in a path array with directory names there\n  // must be no slashes, empty elements, or device names (c:\\) in the array\n  // (so also no leading and trailing slashes - it does not distinguish\n  // relative and absolute paths)\n  function normalizeArray(parts, allowAboveRoot) {\n    // if the path tries to go above the root, `up` ends up > 0\n    var up = 0;\n    for (var i = parts.length; i >= 0; i--) {\n      var last = parts[i];\n      if (last == '.') {\n        parts.splice(i, 1);\n      } else if (last === '..') {\n        parts.splice(i, 1);\n        up++;\n      } else if (up) {\n        parts.splice(i, 1);\n        up--;\n      }\n    }\n\n    // if the path is allowed to go above the root, restore leading ..s\n    if (allowAboveRoot) {\n      for (; up--; up) {\n        parts.unshift('..');\n      }\n    }\n\n    return parts;\n  }\n\n  // Regex to split a filename into [*, dir, basename, ext]\n  // posix version\n  var splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n  // path.resolve([from ...], to)\n  // posix version\n  exports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0)\n        ? arguments[i]\n        : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string' || !path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // collapse . access\n  resolvedPath = resolvedPath.replace(/\\/\\.\\//,'/');\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n      return !!p;\n    }), !resolvedAbsolute).join('/');\n\n    return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n  };\n\n  // path.normalize(path)\n  // posix version\n  exports.normalize = function(path) {\n    var isAbsolute = path.charAt(0) === '/',\n        trailingSlash = path.slice(-1) === '/';\n\n    // Normalize the path\n    path = normalizeArray(filter(path.split('/'), function(p) {\n      return !!p;\n    }), !isAbsolute).join('/');\n\n    if (!path && !isAbsolute) {\n      path = '.';\n    }\n    if (path && trailingSlash) {\n      path += '/';\n    }\n\n    return (isAbsolute ? '/' : '') + path;\n  };\n\n\n  // posix version\n  exports.join = function() {\n    var paths = Array.prototype.slice.call(arguments, 0);\n    return exports.normalize(filter(paths, function(p) {\n      return p && typeof p === 'string';\n    }).join('/'));\n  };\n\n\n  exports.dirname = function(path) {\n    var dir = splitPathRe.exec(path)[1] || '';\n    if (!dir) {\n      // No dirname\n      return '.';\n    } else if (dir === '/') {\n      // It is just a slash or a drive letter with a slash\n      return dir;\n    } else {\n      // It is a full dirname, strip trailing slash\n      return dir.substring(0, dir.length - 1);\n    }\n  };\n\n\n  exports.basename = function(path, ext) {\n    var f = splitPathRe.exec(path)[2] || '';\n    if (ext && f.substr(-1 * ext.length) === ext) {\n      f = f.substr(0, f.length - ext.length);\n    }\n    return f;\n  };\n\n\n  exports.extname = function(path) {\n    return splitPathRe.exec(path)[3] || '';\n  };\n\n});\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/client/bundler/default.js":"// Default bundler implementation\n'use strict';\n\nfunction includeFlags(overrides) {\n  var includes = {\n    css: true,\n    html: true,\n    system: true,\n    initCode: true\n  };\n  if (overrides) {\n    for(var n in overrides) { includes[n] = overrides[n]; }\n  }\n  return includes;\n}\n\n/**\n * @typedef { name:string, path:string, dir:string, content:string, options:string, type:string } AssetEntry\n */\n\n/**\n * @ngdoc service\n * @name bundler.default:default\n * @function\n *\n * @description\n *  The default bundler of HTML, CSS & JS\n *\n * @type {{define: define, load: load, toMinifiedCSS: toMinifiedCSS, toMinifiedJS: toMinifiedJS, asset: {\n *  entries: entries, loader: assetLoader, systemModule: systemModule, js: assetJS, worker: assetWorker, start: assetStart,\n *  css: assetCSS, html: assetHTML}}}\n */\nmodule.exports = function(ss,client,options){\n\n  var bundler = ss.bundler.create({\n    define: define,\n    asset: asset\n  });\n  return bundler;\n\n\n  function define(paths) {\n\n    if (typeof paths.view !== 'string') {\n      throw new Error('You may only define one HTML view per single-page client. Please pass a filename as a string, not an Array');\n    }\n    if (paths.view.lastIndexOf('.') <= 0) {\n      throw new Error('The \\'' + paths.view + '\\' view must have a valid HTML extension (such as .html or .jade)');\n    }\n\n    // Define new client object\n    client.paths = ss.bundler.sourcePaths(paths); //TODO how to handle root being deeper than node_modules\n    client.includes = includeFlags(paths.includes);\n    client.constants = paths.constants || paths.consts;\n    client.locals = paths.locals;\n    client.entryInitPath = ss.bundler.findEntryPoint(client);\n  }\n\n  //TODO callback(err,output) for pack to flag error\n  function asset(entry, opts, cb) {\n    ss.bundler.loadFile(entry, opts, null,\n      function(output) {\n        switch(entry.bundle) {\n          case 'html':\n            return cb(ss.bundler.injectTailIfNeeded(output,opts));\n          case 'css':\n            return cb( client.includes.css? output:'');\n          case 'worker':\n            //TODO\n            if (opts.compress && entry.file.indexOf('.min') === -1) {\n              output = ss.bundler.minifyJSFile(output, entry.file);\n            }\n            break;\n\n          default:\n            //TODO with options compress saved to avoid double compression\n            output = bundler.wrapCode(output, entry, opts);\n            if (opts.compress && entry.file.indexOf('.min') === -1) {\n              output = ss.bundler.minifyJSFile(output, entry.file);\n            }\n            return cb(output);\n        }\n      },\n      function(err) {\n        ss.log.clientIssue(client,options,err,entry);\n        switch(entry.ext) {\n          case 'html':\n            return cb('Couldn\\'t format ' + entry.file + err.userInfoHTML);\n          case 'css':\n            return cb('/* couldn\\'t format ' + entry.file + err.userInfoText+' */');\n          default:\n            return cb('// couldn\\'t format ' + entry.file + err.userInfoText);\n        }\n      });\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/client/bundler/production.js":"'use strict';\n\n//TODO just load from assets folder\n\nmodule.exports = function(ss,client,options){\n\n  var bundler = ss.bundler.create({\n    define: define,\n    asset: asset\n  });\n  return bundler;\n\n\n  function define(paths) {\n\n    if (typeof paths.view !== 'string') {\n      throw new Error('You may only define one HTML view per single-page client. Please pass a filename as a string, not an Array');\n    }\n    if (paths.view.lastIndexOf('.') <= 0) {\n      throw new Error('The \\'' + paths.view + '\\' view must have a valid HTML extension (such as .html or .jade)');\n    }\n\n    // Define new client object\n    client.paths = ss.bundler.sourcePaths(paths);\n    client.constants = paths.constants || paths.consts;\n    client.locals = paths.locals;\n    client.entryInitPath = ss.bundler.findEntryPoint(client);\n  }\n\n  //TODO callback(err,output) for pack to flag error\n  function asset(entry, opts, cb) {\n    ss.bundler.loadFile(entry, opts, null,\n      function(output) {\n        switch(entry.bundle) {\n          case 'html':\n            return cb(ss.bundler.injectTailIfNeeded(output,opts));\n          case 'css':\n            return cb( client.includes.css? output:'');\n          case 'worker':\n            //TODO\n            if (opts.compress && entry.file.indexOf('.min') === -1) {\n              output = ss.bundler.minifyJSFile(output, entry.file);\n            }\n            break;\n\n          default:\n            //TODO with options compress saved to avoid double compression\n            output = bundler.wrapCode(output, entry, opts);\n            if (opts.compress && entry.file.indexOf('.min') === -1) {\n              output = ss.bundler.minifyJSFile(output, entry.file);\n            }\n            return cb(output);\n        }\n      },\n      function(err) {\n        ss.log.clientIssue(client,options,err,entry);\n        switch(entry.ext) {\n          case 'html':\n            return cb('Couldn\\'t format ' + entry.file + err.userInfoHTML);\n          case 'css':\n            return cb('/* couldn\\'t format ' + entry.file + err.userInfoText+' */');\n          default:\n            return cb('// couldn\\'t format ' + entry.file + err.userInfoText);\n        }\n      });\n  }\n};\n\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/client/formatters/jade.js":"'use strict';\n\nvar fs = require('fs'),\n    path = require('path');\n\nmodule.exports = function(ss, config, clientOptions) {\n  config = config || {};\n  if (!config.basedir) {\n    config.basedir = path.join(ss.root, clientOptions.dirs.client);\n  }\n  \n  var jade = ss.require('jade');\n\n  return {\n\n    name: 'Jade',\n    extensions: ['jade'],\n    assetType: 'html',\n    contentType: 'text/html',\n\n    compile: function(path, options, cb) {\n\n      var locals = {};\n\n      // Merge any locals passed to config.locals\n      if (options.locals && typeof(options.locals) === 'object') {\n        for (var attrname in options.locals) { locals[attrname] = options.locals[attrname]; }\n      }\n\n      // If passing optional headers for main view HTML\n      if (options && options.headers) {\n        locals.SocketStream = options.headers;\n      }\n\n      var input = fs.readFileSync(path, 'utf8');\n      var parser = jade.compile(input, Object.create(config, {\n        filename: {value:path}\n      }) );\n      var output = parser(locals);\n\n      cb(output);\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/client/formatters/less.js":"'use strict';\n\nvar fs = require('fs'),\n    pathlib = require('path'),\n    _prependedLess;\n\nexports.prependLess = function(prependedLess) {\n    if(typeof prependedLess === 'string') {\n        _prependedLess = prependedLess;\n    }\n};\n\nfunction errorBodyStyling(root,path, err) {\n    path = path.replace(root,'');\n    var filename = err.filename.replace(root,'');\n    var r = [\n        'body:before {',\n        'display:block;',\n        'position:absolute;',\n        'top:15px; left:20px; right:20px;',\n        'z-index: 10000;',\n        'content:\"Error compiling LESS file: '+path+' at '+(filename||'?')+' '+(err.line||'?')+':'+(err.index||'?')+'   '+err.message+'\";',\n        'border: 1px solid #888;',\n        'border-radius: 5px;',\n        'background-color: rgba(255,255,255,.5);',\n        'background-color: white;',\n        'padding: 10px 15px;',\n        '}'\n    ];\n    return r.join('\\n');\n}\n\nexports.decidePaths = function decidePaths(path, options) {\n\n    var p = [ pathlib.dirname(path) ];\n    //TODO by default we should add the ss.root to paths at end\n    if (options.paths) {\n        p = p.concat(options.paths);\n    }\n    return p;\n};\n\n// root and config are passed as arguments, but are not used\n//\nmodule.exports = function (ss,config) {\n\n    var less = ss.require('less');\n\n    return {\n\n        name: 'Less',\n        extensions: ['less'],\n        assetType: 'css',\n        contentType: 'text/css',\n\n        compile: function(path, options, cb) {\n\n            var input = fs.readFileSync(path, 'utf8');\n\n            if(_prependedLess) {\n                input = _prependedLess + '\\n' + input;\n            }\n            var opts = {};\n            for(var n in config) { opts[n] = config[n]; }\n            opts.filename = path;\n            opts.paths = exports.decidePaths(path, config);\n            opts.compress = options.compress;\n\n            less.logger.addListener({\n                //TODO passing along log output\n                debug: function(/*msg*/) {\n\n                },\n                info: function(/*msg*/) {\n\n                },\n                warn: function(/*msg*/) {\n\n                },\n                error: function(/*msg*/) {\n\n                }\n            });\n            \n            //TODO it seems less still blows up on some path errors, is there a way to catch them?\n\n            less.render(input, opts, function(err, out) {\n                if (err) {\n                    console.log('! - Unable to compile Less file %s into CSS', path);\n                    console.log(err);\n                    return cb(errorBodyStyling(ss, path, err));\n                }\n                //TODO out.map\n                cb(out.css);\n            });\n        }\n    };\n};","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/client/formatters/sass.js":"'use strict';\n\nvar path = require('path'),\n    findup = require('findup-sync');\n\nmodule.exports = function(ss, config, clientOptions) {\n\n  var sass = ss.require('node-sass'),\n      modulesPath = [ findup('node_modules') ]; //TODO get real npm and bower package locations\n\n  console.log(  );\n\n  return {\n\n    name: 'Sass',\n\n    extensions: ['sass', 'scss'],\n\n    assetType: 'css',\n\n    contentType: 'text/css',\n\n    compile: function(srcPath, options, success, error) {\n\n      var opts = {\n        file: srcPath,\n        includePaths: modulesPath.concat([ path.join(ss.root, clientOptions.dirs.client) ])\n      };\n      for(var n in config) {\n        if (n !== 'file') {\n          opts[n] = config[n] || opts[n];\n        }\n      }\n      opts.locals = opts.locals || options.locals;\n      opts.outputStyle = options.compress? \"compressed\":\"nested\";\n\n      sass.render(opts, function(err, result) {\n        if (err) {\n          console.log(err)\n          return error(err);\n        }\n        success(result.css.toString());\n        //TODO result.stats print\n        //TODO result.map.toString\n      });\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/client/template_engines/angular.js":"// Produces inline templates for Angular.js\n// Use them in conjunction with `ng-view`. Note the `.html` at the end of each template name which is automatically appended\n\n'use strict';\n\nexports.init = function() {\n  return {\n    name: 'Angular.js',\n    process: function(template, path, id) {\n      return '<script type=\"text/ng-template\" id=\"' + id + '.html\">' + template + '</script>';\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/client/template_engines/ember.js":"// Produces templates for Ember.js\n// Note Ember compiles these Handlebars templates one time only when you call Em.Application.create();\n'use strict';\n\nexports.init = function() {\n  return {\n    name: 'Ember.js',\n    process: function(template, path, id) {\n      return '<script type=\"text/x-handlebars\" data-template-name=\"' + id + '\">' + template + '</script>';\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/publish/transports/internal.js":"// Publish Event - Internal EventEmitter Transport\n'use strict';\n\nvar EventEmitter2, emitter;\n\nEventEmitter2 = require('eventemitter2').EventEmitter2;\n\nemitter = new EventEmitter2();\n\nmodule.exports = function() {\n  return {\n    listen: function(cb) {\n      return emitter.on('event', cb);\n    },\n    send: function(obj) {\n      return emitter.emit('event', obj);\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/lib/publish/transports/redis.js":"// Publish Event - Redis Transport\n'use strict';\n\nvar redis = require('redis'); //TODO ss.require('redis')\n\nmodule.exports = function(config) {\n  var conn, host, options, port;\n  if (!config) {\n    config = {};\n  }\n\n  // Set options or use the defaults  \n  port = config.port || 6379;\n  host = config.host || '127.0.0.1';\n  options = config.options || {};\n\n  // Redis requires a separate connection for pub/sub  \n  conn = {};\n  ['pub', 'sub'].forEach(function(name) {\n    conn[name] = redis.createClient(port, host, options);\n    if (config.pass) {\n      conn[name].auth(config.pass);\n    }\n    if (config.db) {\n      return conn[name].select(config.db);\n    }\n  });\n  return {\n    listen: function(cb) {\n      conn.sub.subscribe('ss:event');\n      return conn.sub.on('message', function(channel, msg) {\n        return cb(JSON.parse(msg));\n      });\n    },\n    send: function(obj) {\n      var msg;\n      msg = JSON.stringify(obj);\n      return conn.pub.publish('ss:event', msg);\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-socketstream/node_modules/socketstream/new_project/server/rpc/demo.js":"'use strict';\n// Server-side Code\n\n// Define actions which can be called from the client using ss.rpc('demo.ACTIONNAME', param1, param2...)\nexports.actions = function(req, res, ss) {\n\n  // Example of pre-loading sessions into req.session using internal middleware\n  req.use('session');\n\n  // Uncomment line below to use the middleware defined in server/middleware/example\n  //req.use('example.authenticated')\n\n  return {\n\n    sendMessage: function(message) {\n      if (message && message.length > 0) {         // Check for blank messages\n        ss.publish.all('newMessage', message);     // Broadcast the message to everyone\n        return res(true);                          // Confirm it was sent to the originating client\n      } else {\n        return res(false);\n      }\n    }\n\n  };\n\n};"}